# simulation functions# import predefined functionsimport Functions.synaptic_input_functions as sifimport Functions.analysis_functions as afimport Functions.Data_analysis_Zeldenrust_functions as dafZ# import packages for simulation and calculationimport numpy as npimport time as tpfrom brian2 import *# brian2 is unstable with python 3.12. In case of errors either use: #prefs.codegen.target = "numpy"  # orimport osos.environ["CC"] = "gcc"os.environ["CXX"] = "g++"# import packages for data saving import pickle############################# simulation functions Padamsey ############################################################# parameter function ################################def sim_parameters(parameter_mode='CTR', membrane_noise=0.0):     # return CTR or FR parameters        # input    # parameter_mode is the parameter values for either CTR or FR     # membrane_noise is the standard deviation of the membrane noise in mV/ms        # output    # C_m is the membrane capacitance in pF    # E_L is the resting potential (leak reversal potential) in mV    # R_m is the membrane resistance equal to leak resistance in MOhm    # g_L is the leak conductance in nS    # V_thresh is the spike generation threshold in mV    # V_reset is the reset potential in mV    # rate_window is the integration time for the online firing-rate estimation in ms      # E_e is the reversal potential for excitatory inputs in mV    # E_i is the reversal potential for inhibitory inputs in mV    # tau_e is the postsynaptic potential (PSP) time constant for exc. input in ms    # tau_i is the postsynaptic potential (PSP) time constant for inh. input in ms    # Delta_T_ad is the AdExp slope factor    # tau_w_ad is the AdExp adaptation time constant    # a_ad is the AdExp subthreshold adaptation    # b_ad is the AdExp spike-triggered adaptation    # membrane_noise is the standard deviation of the membrane noise in mV/ms        # define neuron parameters    C_m = 100 # membrane capacitance in pF # Padamsey et al. 2022 in vivo: CTR = 105 pF, FR = 99 pF    if parameter_mode == 'CTR':         E_L = -72 # initial resting potential (leak reversal potential) in mV # Padamsey et al. 2022 in vivo: CTR = -72 mV, FR = -66 mV        R_m = 93 # membrane resistance equal to leak resistance in MOhm # Padamsey et al. 2022 in vivo: CTR = 93 MOhm, FR = 113 MOhm    if parameter_mode == 'FR':         E_L = -66 # initial resting potential (leak reversal potential) in mV # Padamsey et al. 2022 in vivo: CTR = -72 mV, FR = -66 mV        R_m = 113 # membrane resistance equal to leak resistance in MOhm # Padamsey et al. 2022 in vivo: CTR = 93 MOhm, FR = 113 MOhm    g_L = 10**(3)/R_m # leak conductance in nS    V_thresh = -50 # spike generation threshold in mV # Padamsey et al. 2022 in vivo: CTR = -20 mV    V_reset = E_L # reset potential in mV # -60 previously        # define rate estimation and Calcium trace    rate_window = 1000 # in ms         # define synaptic parameters    E_e = 0.0 # reversal potential of excitatory synapses in mV    E_i = -80.0 # reversal potential of inhibitory synapses in mV    tau_e = 3.0 # time constant of excitatory synapses in ms # brian 5    tau_i = 5.0 # time constant of inhibitory synapses in ms # brian 10        # AdExp parameters    Delta_T_ad = 2 # AdExp slope factor in mV, originally 2    tau_w_ad = 500 # AdExp adaptation time constant in ms, originally 144    a_ad = 4 # AdExp subthreshold adaptation in nS, originally 4    b_ad = 0.02 # AdExp spike-triggered adaptation in nA, originally 0.08        membrane_noise = membrane_noise # std of membrane noise in mV/ms    return C_m, E_L, R_m, g_L, V_thresh, V_reset, rate_window, E_e, E_i, tau_e, tau_i, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noisedef parameters_brian(T, N_e, N_i, spike_times_e, spike_times_i, E_e, E_i, w_e, w_i, tau_e, tau_i, C_m, g_L, E_L, V_thresh, V_reset, rate_window, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise):    # transforms parameters for brian2        # input and output    # T is the duration of the simulation in ms    # N_e is the number of excitatory synaptic inputs    # N_i is the number of inhibitory synaptic inputs    # spike_times_e is an array of excitatory input spike trains    # spike_times_i is an array of inhibitory input spike trains    # E_e is the reversal potential for excitatory inputs in mV    # E_i is the reversal potential for inhibitory inputs in mV    # w_e are the weights of exc. input    # w_i are the weights of inh. input    # tau_e is the postsynaptic potential (PSP) time constant for exc. input in ms    # tau_i is the postsynaptic potential (PSP) time constant for inh. input in ms    # C_m is the membrane capacitance in pF    # g_L is the leak conductance in nS    # E_L is the resting potential (leak reversal potential) in mV    # V_thresh is the spike generation threshold in mV    # V_reset is the reset potential in mV    # rate_window is the integration time for the online firing-rate estimation in ms    # Delta_T_ad is the AdExp slope factor    # tau_w_ad is the AdExp adaptation time constant    # a_ad is the AdExp subthreshold adaptation    # b_ad is the AdExp spike-triggered adaptation    # membrane_noise is the standard deviation of the membrane noise in mV/ms        T_b = T/1000*second    # define synaptic input     E_e_b = E_e*mV    E_i_b = E_i*mV    w_e_b = w_e*nS    w_i_b = w_i*nS    tau_e_b = tau_e*ms    tau_i_b = tau_i*ms        # define neuron parameters    C_m_b = C_m*pF  # Membrane capacitance    g_L_b = g_L*nS  # Leak conductance    E_L_b = E_L*mV  # Resting potential    V_thresh_b = V_thresh*mV  # Spike generation threshold    V_reset_b = V_reset*mV  # reset potential    # define rate estimation     rate_window_b = rate_window*ms        Delta_T_ad_b = Delta_T_ad * mV  # AdExp slope factor    tau_w_ad_b = tau_w_ad * ms  # AdExp adaptation time constant    a_ad_b = a_ad * nS  # AdExp subthreshold adaptation    b_ad_b = b_ad * nA # AdExp spike-triggered adaptation        membrane_noise_b = membrane_noise * mV/ms # std of the membrane noise     return T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_b, w_i_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_b, V_thresh_b, V_reset_b, rate_window_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, membrane_noise_bdef load_experimental_data():    # load experimental (CTR & FR) in vivo data    # input    # output    # exp_data is a tuple of CTR & FR experimental in vivo data        R_m_CTR_in_vivo_filtered_III = np.array([118.1417619 ,  56.49015612,  65.34178329, 109.1892098 , 100.0066801 , 111.1255604 ,  65.34178328,  89.69883735, 77.92321383,  72.48631469,  91.99935923,  64.76940172, 94.72902432,  96.37571531,  92.55105357])    E_L_CTR_in_vivo_filtered_III = np.array([-55.07387263, -51.07797503, -89.91033449, -63.96205221, -62.02312819, -86.59056523, -91.43247544, -55.40377024, -63.74696882, -81.33220614, -81.94520611, -65.95244974, -52.27432139, -60.79497506, -73.44615479])    w_scale_0_CTR_in_vivo_filtered_III = np.array([0.0058625, 0.001125 , 0.0421   , 0.0115   , 0.00965  , 0.0232   , 0.03125  , 0.00418  , 0.01126  , 0.028397 , 0.02967  , 0.016875 , 0.00238  , 0.010061 , 0.01897  ])    r_post_CTR_in_vivo_filtered_III = np.array([2.333165  , 0.01245774, 0.44847876, 0.26784148, 0.09966195, 0.09135678, 0.01868662, 0.02491549, 0.02906807, 0.13952672, 0.7474646 , 0.13703518, 0.43352947, 0.29400274, 0.14949292])        # load FR in vivo experimental data    R_m_FR_in_vivo_filtered_III = np. array([ 59.5414375 ,  90.61519383, 112.1973449 , 109.2409449 , 113.6195918 ,  94.55301741, 100.2321156 ,  93.29399714, 105.1830003 , 108.5535213 , 112.9435073 ])    E_L_FR_in_vivo_filtered_III = np.array([-65.18810356, -84.37127031, -71.20323163, -69.68623191, -65.43870612, -55.02341096, -56.51534719, -87.67634728, -67.84683416, -53.43207761, -77.35007804])    w_scale_0_FR_in_vivo_filtered_III = np.array([0.01313  , 0.02466  , 0.01793  , 0.01336  , 0.01066  , 0.004428 , 0.004    , 0.02822  , 0.0217   , 0.0025875, 0.0152   ])    r_post_FR_in_vivo_filtered_III = np.array([0.01794742, 0.05813614, 0.57502756, 0.04484788, 0.04983097, 0.12042485, 0.01661032, 0.14118776, 3.60028782, 0.03737323, 0.02491549])        # pack data into tuples     exp_data_CTR = (R_m_CTR_in_vivo_filtered_III,E_L_CTR_in_vivo_filtered_III,w_scale_0_CTR_in_vivo_filtered_III,r_post_CTR_in_vivo_filtered_III)    exp_data_FR = (R_m_FR_in_vivo_filtered_III,E_L_FR_in_vivo_filtered_III,w_scale_0_FR_in_vivo_filtered_III,r_post_FR_in_vivo_filtered_III)        exp_data = (exp_data_CTR, exp_data_FR)    return exp_data####################################### saving functions ###################################################################def empty_results_dictionary():     # initialize a results dictionary with empty lists        # output    # results dictionary with empty lists        results_template = {        'V_m': [],        'I_syn_e': [],        'I_syn_i': [],        'spike_times_post': [], # to reduce size of dictionary        'r_post': [],        'E_tot': [],        'CV_V_m': [],        'tuning_curve': [],        'OSI': [],        'OSI_per_energy': [],        'CV_ISI_tuning_curve': [],        'CV_ISI_tuning_curve_per_energy': [],        'MI_tuning_curve': [],        'MI_tuning_curve_per_energy': [],        'MICE_tuning_curve': [],        'MICE_tuning_curve_per_energy': [],        'CV_ISI': [],        'CV_ISI_per_energy': [],        'MI': [],        'MI_per_energy': [],        'TE': [],        'TE_per_energy': [],        'MICE': [],        'MICE_per_energy': [],        'TECE': [],        'TECE_per_energy': []}        return results_templatedef save_results_dictionary(V_m, I_syn_e, I_syn_i, spike_times_post, r_post, E_tot, CV_V_m, tuning_curve, OSI, OSI_per_energy, CV_ISI_tuning_curve, CV_ISI_tuning_curve_per_energy, MI_tuning_curve, MI_tuning_curve_per_energy, MICE_tuning_curve, MICE_tuning_curve_per_energy, CV_ISI, CV_ISI_per_energy, MI, MI_per_energy, TE, TE_per_energy, MICE, MICE_per_energy, TECE, TECE_per_energy):    # save results dictionary        # output    # results dictionary        results = {        'V_m': np.mean(V_m),        'I_syn_e': np.mean(I_syn_e),        'I_syn_i': np.mean(I_syn_i),        'spike_times_post': spike_times_post,  # to reduce size of dictionary        'r_post': r_post,        'E_tot': E_tot,        'CV_V_m': CV_V_m,        'tuning_curve': tuning_curve,        'OSI': OSI,        'OSI_per_energy': OSI_per_energy,        'CV_ISI_tuning_curve': CV_ISI_tuning_curve,        'CV_ISI_tuning_curve_per_energy': CV_ISI_tuning_curve_per_energy,        'MI_tuning_curve': MI_tuning_curve,        'MI_tuning_curve_per_energy': MI_tuning_curve_per_energy,        'MICE_tuning_curve': MICE_tuning_curve,        'MICE_tuning_curve_per_energy': MICE_tuning_curve_per_energy,        'CV_ISI': CV_ISI,        'CV_ISI_per_energy': CV_ISI_per_energy,        'MI': MI,        'MI_per_energy': MI_per_energy,        'TE': TE,        'TE_per_energy': TE_per_energy,        'MICE': MICE,        'MICE_per_energy': MICE_per_energy,        'TECE': TECE,        'TECE_per_energy': TECE_per_energy}        return results################################ LIF & AdExp function ################################def LIF(T, N_e, N_i, spike_times_e, spike_times_i, E_e, E_i, w_e, w_i, tau_e, tau_i, C_m, g_L, E_L, V_thresh, V_reset, rate_window, membrane_noise):    # simulation LIF model        # input    # T is the duration of the simulation in ms    # N_e is the number of excitatory synaptic inputs    # N_i is the number of inhibitory synaptic inputs    # spike_times_e is an array of excitatory input spike trains    # spike_times_i is an array of inhibitory input spike trains    # E_e is the reversal potential for excitatory inputs in mV    # E_i is the reversal potential for inhibitory inputs in mV    # w_e are the weights of exc. input    # w_i are the weights of inh. input    # tau_e is the postsynaptic potential (PSP) time constant for exc. input in ms    # tau_i is the postsynaptic potential (PSP) time constant for inh. input in ms    # C_m is the membrane capacitance in pF    # g_L is the leak conductance in nS    # E_L is the resting potential (leak reversal potential) / mV    # V_thresh is the spike generation threshold in mV    # V_reset is the reset potential in mV    # rate_window is the integration time for the online firing-rate estimation in ms    # membrane_noise is the standard deviation of the membrane noise in mV/ms    # output     # time is an array of length n of the time    # V_m is an array of length n of the membrane voltage    # spike_times_post is a list of postsynaptic spike times    # rate_estimate_post  is an array of length n of instantaneous firing rates    # I_syn_e is an array of length n of excitatory synaptic current    # I_syn_i is an array of length n of inhibitory synaptic current    # g_e is an array of length n of excitatory conductances    # g_i is an array of length n of inhibitory conductances    start_scope()    #defaultclock.dt = dt*ms    N = 1  # number of postsynaptic neurons        if membrane_noise == 0.0:         eqs = '''        dV_m/dt = (g_L*(E_L-V_m) + I_syn_e + I_syn_i) / C_m : volt        I_syn_e = g_e*(E_e-V_m) : amp        I_syn_i = g_i*(E_i-V_m) : amp        dg_e/dt = -g_e/tau_e : siemens        dg_i/dt = -g_i/tau_i : siemens        '''                neuron = NeuronGroup(N, model=eqs, threshold='V_m > V_thresh', reset='V_m = V_reset', method='rk4')        neuron.V_m = V_reset            if membrane_noise > 0.0:         eqs = '''        dV_m/dt = (g_L*(E_L-V_m) + I_syn_e + I_syn_i) / C_m + membrane_noise*xi*sqrt(dt) : volt        I_syn_e = g_e*(E_e-V_m) : amp        I_syn_i = g_i*(E_i-V_m) : amp        dg_e/dt = -g_e/tau_e : siemens        dg_i/dt = -g_i/tau_i : siemens        '''        # for temporally correlated noise multiply noise term with * sqrt(2/tau_noise) with tau_noise=5–50 ms                neuron = NeuronGroup(N, model=eqs, threshold='V_m > V_thresh', reset='V_m = V_reset', method='euler')        neuron.V_m = V_reset        # convert spike_times_e and spike_times_i to SpikeGeneratorGroup format    indices_e, times_e = zip(*[(i, spike) for i, spikes in spike_times_e.items() for spike in spikes])    indices_i, times_i = zip(*[(i, spike) for i, spikes in spike_times_i.items() for spike in spikes])    G_e = SpikeGeneratorGroup(N_e, indices_e, times_e)    G_i = SpikeGeneratorGroup(N_i, indices_i, times_i)    exc_synapses = Synapses(G_e, neuron, 'w: siemens', on_pre='g_e += w')    exc_synapses.connect()    for i, weight in enumerate(w_e):        exc_synapses.w[i] = weight    inh_synapses = Synapses(G_i, neuron, 'w: siemens', on_pre='g_i += w')    inh_synapses.connect()    for i, weight in enumerate(w_i):        inh_synapses.w[i] = weight    spikes = SpikeMonitor(neuron)    rate_monitor = PopulationRateMonitor(neuron)    post_states = StateMonitor(neuron, ('V_m', 'I_syn_e', 'I_syn_i', 'g_e', 'g_i'), record=True)        run(T, report='text')    time = post_states.t / second    V_m = post_states.V_m[0] / mV    spike_times_post = spikes.t / ms    rate_estimate_post = rate_monitor.smooth_rate(window='flat', width=rate_window) / Hz # alternative window mode 'gaussian'    I_syn_e = post_states.I_syn_e[0] / nA    I_syn_i = post_states.I_syn_i[0] / nA    g_e = post_states.g_e[0] / nS    g_i = post_states.g_i[0] / nS        return time, V_m, spike_times_post, rate_estimate_post, I_syn_e, I_syn_i, g_e, g_idef AdExp(T, N_e, N_i, spike_times_e, spike_times_i, E_e, E_i, w_e, w_i, tau_e, tau_i, C_m, g_L, E_L, V_thresh, V_reset, Delta_T, tau_w, a, b, rate_window, membrane_noise):    # simulation AdExp model        # input    # T is the duration of the simulation in ms    # N_e is the number of excitatory synaptic inputs    # N_i is the number of inhibitory synaptic inputs    # spike_times_e is an array of excitatory input spike trains    # spike_times_i is an array of inhibitory input spike trains    # E_e is the reversal potential for excitatory inputs in mV    # E_i is the reversal potential for inhibitory inputs in mV    # w_e are the weights of exc. input    # w_i are the weights of inh. input    # tau_e is the postsynaptic potential (PSP) time constant for exc. input in ms    # tau_i is the postsynaptic potential (PSP) time constant for inh. input in ms    # C_m is the membrane capacitance in pF    # g_L is the leak conductance in nS    # E_L is the resting potential (leak reversal potential) / mV    # V_thresh is the spike generation threshold in mV    # V_reset is the reset potential in mV    # Delta_T is the slope factor in mV    # tau_w is the adaptation time constant in ms    # a is the subthreshold adaptation in nS    # b is the spike-triggered adaptation in pA    # rate_window is the integration time for the online firing-rate estimation in ms    # membrane_noise is the standard deviation of the membrane noise in mV/ms    # output     # time is an array of length n of the time    # V_m is an array of length n of the membrane voltage    # spike_times_post is a list of postsynaptic spike times    # rate_estimate_post  is an array of length n of instantaneous firing rates    # I_syn_e is an array of length n of excitatory synaptic current    # I_syn_i is an array of length n of inhibitory synaptic current    # g_e is an array of length n of excitatory conductances    # g_i is an array of length n of inhibitory conductances    start_scope()    #defaultclock.dt = dt*ms    N = 1  # number of postsynaptic neurons        # define V_T & spiking threshold    V_T = V_thresh - 2.5 * Delta_T    V_thresh_spike_detection = V_thresh + 2.5 * Delta_T        if membrane_noise == 0.0:         eqs = '''        dV_m/dt = (g_L*(E_L - V_m) + g_L*Delta_T*exp((V_m - V_T)/Delta_T) - w_ad + I_syn_e + I_syn_i) / C_m : volt        dw_ad/dt = (a*(V_m - E_L) - w_ad) / tau_w : amp        I_syn_e = g_e*(E_e - V_m) : amp        I_syn_i = g_i*(E_i - V_m) : amp        dg_e/dt = -g_e / tau_e : siemens        dg_i/dt = -g_i / tau_i : siemens        '''                neuron = NeuronGroup(N, model=eqs, threshold='V_m > V_thresh_spike_detection', reset='V_m = V_reset; w_ad += b', method='exponential_euler')        neuron.V_m = V_reset            if membrane_noise > 0.0:         eqs = '''        dV_m/dt = (g_L*(E_L - V_m) + g_L*Delta_T*exp((V_m - V_T)/Delta_T) - w_ad + I_syn_e + I_syn_i) / C_m + membrane_noise*xi*sqrt(dt)  : volt        dw_ad/dt = (a*(V_m - E_L) - w_ad) / tau_w : amp        I_syn_e = g_e*(E_e - V_m) : amp        I_syn_i = g_i*(E_i - V_m) : amp        dg_e/dt = -g_e / tau_e : siemens        dg_i/dt = -g_i / tau_i : siemens        '''        # for temporally correlated noise multiply noise term with * sqrt(2/tau_noise) with tau_noise=5–50 ms                neuron = NeuronGroup(N, model=eqs, threshold='V_m > V_thresh_spike_detection', reset='V_m = V_reset; w_ad += b', method='euler')        neuron.V_m = V_reset                # convert spike_times_e and spike_times_i to SpikeGeneratorGroup format    indices_e, times_e = zip(*[(i, spike) for i, spikes in spike_times_e.items() for spike in spikes])    indices_i, times_i = zip(*[(i, spike) for i, spikes in spike_times_i.items() for spike in spikes])    G_e = SpikeGeneratorGroup(N_e, indices_e, times_e)    G_i = SpikeGeneratorGroup(N_i, indices_i, times_i)    exc_synapses = Synapses(G_e, neuron, 'w: siemens', on_pre='g_e += w')    exc_synapses.connect()    for i, weight in enumerate(w_e):        exc_synapses.w[i] = weight    inh_synapses = Synapses(G_i, neuron, 'w: siemens', on_pre='g_i += w')    inh_synapses.connect()    for i, weight in enumerate(w_i):        inh_synapses.w[i] = weight    spikes = SpikeMonitor(neuron)    rate_monitor = PopulationRateMonitor(neuron)    post_states = StateMonitor(neuron, ('V_m', 'I_syn_e', 'I_syn_i', 'g_e', 'g_i'), record=True)        run(T, report='text')    time = post_states.t / second    V_m = post_states.V_m[0] / mV    spike_times_post = spikes.t / ms    rate_estimate_post = rate_monitor.smooth_rate(window='flat', width=rate_window) / Hz # alternative window mode 'gaussian'    I_syn_e = post_states.I_syn_e[0] / nA    I_syn_i = post_states.I_syn_i[0] / nA    g_e = post_states.g_e[0] / nS    g_i = post_states.g_i[0] / nS    return time, V_m, spike_times_post, rate_estimate_post, I_syn_e, I_syn_i, g_e, g_i################################ synpatic input fitting functions ################################def single_CTR_FR_N_e_signal_ratio_run(model_mode, membrane_noise=0.0, synaptic_scaling_mode='multiplicative', N_e_signal_ratio=0.5):    # run a single CTR & FR simulation        # input    # model_mode is a list of strings or string & decides which model is used for simulation    # membrane_noise is the standard deviation of the membrane noise in mV/ms    # synaptic_scaling_mode decides if synaptic weight distribution is scaled multiplicatively or non-multiplicatively    # N_e_signal_ratio portion of signalling synapses        # output     # results_LIF, results_AdExp are the results dictionaries    # initialize dictionaries to save results    results_CTR_LIF, results_FR_LIF, results_CTR_AdExp, results_FR_AdExp = {}, {}, {}, {}    # load parameter values    # define synaptic input    if synaptic_scaling_mode == 'multiplicative':         N_syn, N_e, _, N_i, rate_background_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, mu_weight_e, sigma_weight_e, mu_weight_i, sigma_weight_i = sif.synaptic_parameters(synaptic_scaling_mode=synaptic_scaling_mode)                # orientation variation input        w_e_0, w_i_0, spike_times_e, spike_times_i, r_e, r_i, t_stim, T, N_e_signal, N_e_noise = sif.orientation_variation_input(N_e, N_i, N_e_signal_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, rate_background_ratio, mu_weight_e, sigma_weight_e, mu_weight_i, sigma_weight_i)        w_e_0_CTR, w_i_0_CTR, w_e_0_FR, w_i_0_FR = w_e_0, w_i_0, w_e_0, w_i_0            if synaptic_scaling_mode == 'non-multiplicative':         N_syn, N_e, _, N_i, rate_background_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, mu_weight_e_CTR, sigma_weight_e_CTR, mu_weight_i_CTR, sigma_weight_i_CTR, mu_weight_e_FR, sigma_weight_e_FR, mu_weight_i_FR, sigma_weight_i_FR = sif.synaptic_parameters(synaptic_scaling_mode=synaptic_scaling_mode)        w_e_0_CTR, w_i_0_CTR, spike_times_e, spike_times_i, r_e, r_i, t_stim, T, N_e_signal, N_e_noise = sif.orientation_variation_input(N_e, N_i, N_e_signal_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, rate_background_ratio, mu_weight_e_CTR, sigma_weight_e_CTR, mu_weight_i_CTR, sigma_weight_i_CTR)        w_e_0_FR, w_i_0_FR, _, _, _, _, _, _, _, _ = sif.orientation_variation_input(N_e, N_i, N_e_signal_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, rate_background_ratio, mu_weight_e_FR, sigma_weight_e_FR, mu_weight_i_FR, sigma_weight_i_FR)        # load CTR parameter values    C_m, E_L_CTR, R_m_CTR, g_L_CTR, V_thresh, V_reset_CTR, rate_window, E_e, E_i, tau_e, tau_i, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise = sim_parameters(parameter_mode='CTR', membrane_noise=membrane_noise)    # load FR parameter values    C_m, E_L_FR, R_m_FR, g_L_FR, V_thresh, V_reset_FR, rate_window, E_e, E_i, tau_e, tau_i, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise = sim_parameters(parameter_mode='FR', membrane_noise=membrane_noise)    # scale CTR synaptic input    w_scale_CTR = 100 #45    w_e_CTR = w_e_0_CTR * 5 * w_scale_CTR * 4 # low E/I balance: 4/1    w_i_CTR = w_i_0_CTR * 5 * w_scale_CTR * 1 # low E/I balance: 4/1    # scale FR synaptic input    w_scale_FR = w_scale_CTR*0.7    w_e_FR = w_e_0_FR * 5 * w_scale_FR * 4 # low E/I balance: 4/1    w_i_FR = w_i_0_FR * 5 * w_scale_FR * 1 # low E/I balance: 4/1    # translate CTR to Brian-readable values    T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_CTR_b, w_i_CTR_b, tau_e_b, tau_i_b, C_m_b, g_L_CTR_b, E_L_CTR_b, V_thresh_b, V_reset_CTR_b, rate_window_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, membrane_noise_b = parameters_brian(T, N_e, N_i, spike_times_e, spike_times_i, E_e, E_i, w_e_CTR, w_i_CTR, tau_e, tau_i, C_m, g_L_CTR, E_L_CTR, V_thresh, V_reset_CTR, rate_window, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise)        # translate FR to Brian-readable values    T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_FR_b, w_i_FR_b, tau_e_b, tau_i_b, C_m_b, g_L_FR_b, E_L_FR_b, V_thresh_b, V_reset_FR_b, rate_window_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, membrane_noise_b = parameters_brian(T, N_e, N_i, spike_times_e, spike_times_i, E_e, E_i, w_e_FR, w_i_FR, tau_e, tau_i, C_m, g_L_FR, E_L_FR, V_thresh, V_reset_FR, rate_window, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise)        # simulate LIF if given        if 'LIF' in model_mode:                # scale synaptic input        w_e_CTR_LIF_b = w_e_CTR_b        w_i_CTR_LIF_b = w_i_CTR_b        w_e_FR_LIF_b = w_e_FR_b        w_i_FR_LIF_b = w_i_FR_b        # simulate LIF        time_CTR_LIF, V_m_CTR_LIF, spike_times_post_CTR_LIF, rate_estimate_post_CTR_LIF, I_syn_e_CTR_LIF, I_syn_i_CTR_LIF, g_e_CTR_LIF, g_i_CTR_LIF = LIF(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_CTR_LIF_b, w_i_CTR_LIF_b, tau_e_b, tau_i_b, C_m_b, g_L_CTR_b, E_L_CTR_b, V_thresh_b, V_reset_CTR_b, rate_window_b, membrane_noise_b)        time_FR_LIF, V_m_FR_LIF, spike_times_post_FR_LIF, rate_estimate_post_FR_LIF, I_syn_e_FR_LIF, I_syn_i_FR_LIF, g_e_FR_LIF, g_i_FR_LIF = LIF(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_FR_LIF_b, w_i_FR_LIF_b, tau_e_b, tau_i_b, C_m_b, g_L_FR_b, E_L_FR_b, V_thresh_b, V_reset_FR_b, rate_window_b, membrane_noise_b)        # run full LIF analysis        r_post_CTR_LIF, E_tot_CTR_LIF, CV_V_m_CTR_LIF, tuning_curve_CTR_LIF, OSI_CTR_LIF, OSI_per_energy_CTR_LIF, CV_ISI_tuning_curve_CTR_LIF, CV_ISI_tuning_curve_per_energy_CTR_LIF, MI_tuning_curve_CTR_LIF, MI_tuning_curve_per_energy_CTR_LIF, MICE_tuning_curve_CTR_LIF, MICE_tuning_curve_per_energy_CTR_LIF, CV_ISI_CTR_LIF, CV_ISI_per_energy_CTR_LIF, MI_CTR_LIF, MI_per_energy_CTR_LIF, TE_CTR_LIF, TE_per_energy_CTR_LIF, MICE_CTR_LIF, MICE_per_energy_CTR_LIF, TECE_CTR_LIF, TECE_per_energy_CTR_LIF, E_vec_CTR_LIF = af.complete_analysis(spike_times_post_CTR_LIF, V_m_CTR_LIF, T, R_m_CTR, C_m, E_L_CTR, I_syn_e_CTR_LIF, V_thresh, spike_times_e, w_e_CTR, N_e_noise)        r_post_FR_LIF, E_tot_FR_LIF, CV_V_m_FR_LIF, tuning_curve_FR_LIF, OSI_FR_LIF, OSI_per_energy_FR_LIF, CV_ISI_tuning_curve_FR_LIF, CV_ISI_tuning_curve_per_energy_FR_LIF, MI_tuning_curve_FR_LIF, MI_tuning_curve_per_energy_FR_LIF, MICE_tuning_curve_FR_LIF, MICE_tuning_curve_per_energy_FR_LIF, CV_ISI_FR_LIF, CV_ISI_per_energy_FR_LIF, MI_FR_LIF, MI_per_energy_FR_LIF, TE_FR_LIF, TE_per_energy_FR_LIF, MICE_FR_LIF, MICE_per_energy_FR_LIF, TECE_FR_LIF, TECE_per_energy_FR_LIF, E_vec_FR_LIF = af.complete_analysis(spike_times_post_FR_LIF, V_m_FR_LIF, T, R_m_FR, C_m, E_L_FR, I_syn_e_FR_LIF, V_thresh, spike_times_e, w_e_FR, N_e_noise)                      # save CTR results in LIF dictionary         results_CTR_LIF = save_results_dictionary(V_m_CTR_LIF, I_syn_e_CTR_LIF, I_syn_i_CTR_LIF, spike_times_post_CTR_LIF, r_post_CTR_LIF, E_tot_CTR_LIF, CV_V_m_CTR_LIF, tuning_curve_CTR_LIF, OSI_CTR_LIF, OSI_per_energy_CTR_LIF, CV_ISI_tuning_curve_CTR_LIF, CV_ISI_tuning_curve_per_energy_CTR_LIF, MI_tuning_curve_CTR_LIF, MI_tuning_curve_per_energy_CTR_LIF, MICE_tuning_curve_CTR_LIF, MICE_tuning_curve_per_energy_CTR_LIF, CV_ISI_CTR_LIF, CV_ISI_per_energy_CTR_LIF, MI_CTR_LIF, MI_per_energy_CTR_LIF, TE_CTR_LIF, TE_per_energy_CTR_LIF, MICE_CTR_LIF, MICE_per_energy_CTR_LIF, TECE_CTR_LIF, TECE_per_energy_CTR_LIF)        # save FR results in LIF dictionary          results_FR_LIF = save_results_dictionary(V_m_FR_LIF, I_syn_e_FR_LIF, I_syn_i_FR_LIF, spike_times_post_FR_LIF, r_post_FR_LIF, E_tot_FR_LIF, CV_V_m_FR_LIF, tuning_curve_FR_LIF, OSI_FR_LIF, OSI_per_energy_FR_LIF, CV_ISI_tuning_curve_FR_LIF, CV_ISI_tuning_curve_per_energy_FR_LIF, MI_tuning_curve_FR_LIF, MI_tuning_curve_per_energy_FR_LIF, MICE_tuning_curve_FR_LIF, MICE_tuning_curve_per_energy_FR_LIF, CV_ISI_FR_LIF, CV_ISI_per_energy_FR_LIF, MI_FR_LIF, MI_per_energy_FR_LIF, TE_FR_LIF, TE_per_energy_FR_LIF, MICE_FR_LIF, MICE_per_energy_FR_LIF, TECE_FR_LIF, TECE_per_energy_FR_LIF)            # simulate AdExp if given      if 'AdExp' in model_mode:                       # scale synaptic input        weight_factor_LIF_to_AdExp = 1.0 #1.5        w_e_CTR_AdExp_b = w_e_CTR_b * weight_factor_LIF_to_AdExp        w_i_CTR_AdExp_b = w_i_CTR_b * weight_factor_LIF_to_AdExp        w_e_FR_AdExp_b = w_e_FR_b * weight_factor_LIF_to_AdExp        w_i_FR_AdExp_b = w_i_FR_b * weight_factor_LIF_to_AdExp                # simulate AdExp        time_CTR_AdExp, V_m_CTR_AdExp, spike_times_post_CTR_AdExp, rate_estimate_post_CTR_AdExp, I_syn_e_CTR_AdExp, I_syn_i_CTR_AdExp, g_e_CTR_AdExp, g_i_CTR_AdExp = AdExp(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_CTR_AdExp_b, w_i_CTR_AdExp_b, tau_e_b, tau_i_b, C_m_b, g_L_CTR_b, E_L_CTR_b, V_thresh_b, V_reset_CTR_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, rate_window_b, membrane_noise_b)        time_FR_AdExp, V_m_FR_AdExp, spike_times_post_FR_AdExp, rate_estimate_post_FR_AdExp, I_syn_e_FR_AdExp, I_syn_i_FR_AdExp, g_e_FR_AdExp, g_i_FR_AdExp = AdExp(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_FR_AdExp_b, w_i_FR_AdExp_b, tau_e_b, tau_i_b, C_m_b, g_L_FR_b, E_L_FR_b, V_thresh_b, V_reset_FR_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, rate_window_b, membrane_noise_b)                # run full AdExp analysis        r_post_CTR_AdExp, E_tot_CTR_AdExp, CV_V_m_CTR_AdExp, tuning_curve_CTR_AdExp, OSI_CTR_AdExp, OSI_per_energy_CTR_AdExp, CV_ISI_tuning_curve_CTR_AdExp, CV_ISI_tuning_curve_per_energy_CTR_AdExp, MI_tuning_curve_CTR_AdExp, MI_tuning_curve_per_energy_CTR_AdExp, MICE_tuning_curve_CTR_AdExp, MICE_tuning_curve_per_energy_CTR_AdExp, CV_ISI_CTR_AdExp, CV_ISI_per_energy_CTR_AdExp, MI_CTR_AdExp, MI_per_energy_CTR_AdExp, TE_CTR_AdExp, TE_per_energy_CTR_AdExp, MICE_CTR_AdExp, MICE_per_energy_CTR_AdExp, TECE_CTR_AdExp, TECE_per_energy_CTR_AdExp, E_vec_CTR_AdExp = af.complete_analysis(spike_times_post_CTR_AdExp, V_m_CTR_AdExp, T, R_m_CTR, C_m, E_L_CTR, I_syn_e_CTR_AdExp, V_thresh, spike_times_e, w_e_CTR, N_e_noise)        r_post_FR_AdExp, E_tot_FR_AdExp, CV_V_m_FR_AdExp, tuning_curve_FR_AdExp, OSI_FR_AdExp, OSI_per_energy_FR_AdExp, CV_ISI_tuning_curve_FR_AdExp, CV_ISI_tuning_curve_per_energy_FR_AdExp, MI_tuning_curve_FR_AdExp, MI_tuning_curve_per_energy_FR_AdExp, MICE_tuning_curve_FR_AdExp, MICE_tuning_curve_per_energy_FR_AdExp, CV_ISI_FR_AdExp, CV_ISI_per_energy_FR_AdExp, MI_FR_AdExp, MI_per_energy_FR_AdExp, TE_FR_AdExp, TE_per_energy_FR_AdExp, MICE_FR_AdExp, MICE_per_energy_FR_AdExp, TECE_FR_AdExp, TECE_per_energy_FR_AdExp, E_vec_FR_AdExp = af.complete_analysis(spike_times_post_FR_AdExp, V_m_FR_AdExp, T, R_m_FR, C_m, E_L_FR, I_syn_e_FR_AdExp, V_thresh, spike_times_e, w_e_FR, N_e_noise)        # save CTR results in AdExp dictionary         results_CTR_AdExp = save_results_dictionary(V_m_CTR_AdExp, I_syn_e_CTR_AdExp, I_syn_i_CTR_AdExp, spike_times_post_CTR_AdExp, r_post_CTR_AdExp, E_tot_CTR_AdExp, CV_V_m_CTR_AdExp, tuning_curve_CTR_AdExp, OSI_CTR_AdExp, OSI_per_energy_CTR_AdExp, CV_ISI_tuning_curve_CTR_AdExp, CV_ISI_tuning_curve_per_energy_CTR_AdExp, MI_tuning_curve_CTR_AdExp, MI_tuning_curve_per_energy_CTR_AdExp, MICE_tuning_curve_CTR_AdExp, MICE_tuning_curve_per_energy_CTR_AdExp, CV_ISI_CTR_AdExp, CV_ISI_per_energy_CTR_AdExp, MI_CTR_AdExp, MI_per_energy_CTR_AdExp, TE_CTR_AdExp, TE_per_energy_CTR_AdExp, MICE_CTR_AdExp, MICE_per_energy_CTR_AdExp, TECE_CTR_AdExp, TECE_per_energy_CTR_AdExp)        # save FR results in AdExp dictionary         results_FR_AdExp = save_results_dictionary(V_m_FR_AdExp, I_syn_e_FR_AdExp, I_syn_i_FR_AdExp, spike_times_post_FR_AdExp, r_post_FR_AdExp, E_tot_FR_AdExp, CV_V_m_FR_AdExp, tuning_curve_FR_AdExp, OSI_FR_AdExp, OSI_per_energy_FR_AdExp, CV_ISI_tuning_curve_FR_AdExp, CV_ISI_tuning_curve_per_energy_FR_AdExp, MI_tuning_curve_FR_AdExp, MI_tuning_curve_per_energy_FR_AdExp, MICE_tuning_curve_FR_AdExp, MICE_tuning_curve_per_energy_FR_AdExp, CV_ISI_FR_AdExp, CV_ISI_per_energy_FR_AdExp, MI_FR_AdExp, MI_per_energy_FR_AdExp, TE_FR_AdExp, TE_per_energy_FR_AdExp, MICE_FR_AdExp, MICE_per_energy_FR_AdExp, TECE_FR_AdExp, TECE_per_energy_FR_AdExp)            return results_CTR_LIF, results_FR_LIF, results_CTR_AdExp, results_FR_AdExpdef multiple_CTR_FR_N_e_signal_ratio_runs(number_single_runs, model_mode, membrane_noise=0.0, synaptic_scaling_mode='multiplicative', N_e_signal_ratio=0.5, savename=None):    # run a multiple CTR & FR simulations        # input    # number_single_runs is the number of single runs to perform    # model_mode is a list of strings or string & decides which model is used for simulation    # membrane_noise is the standard deviation of the membrane noise in mV/ms    # synaptic_scaling_mode decides if synaptic weight distribution is scaled multiplicatively or non-multiplicatively    # N_e_signal_ratio portion of signalling synapses    # savename is the name to save the grid as .pkl file    # output     # results_LIF, results_AdExp are the results dictionaries    # initialize dictionaries to save results    results_single_runs_CTR_LIF, results_single_runs_FR_LIF, results_single_runs_CTR_AdExp, results_single_runs_FR_AdExp = empty_results_dictionary(), empty_results_dictionary(), empty_results_dictionary(), empty_results_dictionary()        for _ in range(0, number_single_runs):                 # simulate single run        results_CTR_LIF, results_FR_LIF, results_CTR_AdExp, results_FR_AdExp = single_CTR_FR_N_e_signal_ratio_run(model_mode=model_mode, membrane_noise=membrane_noise, synaptic_scaling_mode=synaptic_scaling_mode, N_e_signal_ratio=N_e_signal_ratio)        for key, value in results_CTR_LIF.items():            results_single_runs_CTR_LIF[key].append(value)                for key, value in results_FR_LIF.items():            results_single_runs_FR_LIF[key].append(value)                for key, value in results_CTR_AdExp.items():            results_single_runs_CTR_AdExp[key].append(value)                for key, value in results_FR_AdExp.items():            results_single_runs_FR_AdExp[key].append(value)        # save results if savename is provided    if savename is not None:        if 'LIF' in model_mode:            with open(f'../Data/tuning_curve_N_e_signal_ratio/{savename}_results_single_runs_CTR_LIF.pkl', 'wb') as f:                pickle.dump(results_single_runs_CTR_LIF, f)            with open(f'../Data/tuning_curve_N_e_signal_ratio/{savename}_results_single_runs_FR_LIF.pkl', 'wb') as f:                pickle.dump(results_single_runs_FR_LIF, f)        if 'AdExp' in model_mode:            with open(f'../Data/tuning_curve_N_e_signal_ratio/{savename}_results_single_runs_CTR_AdExp.pkl', 'wb') as f:                pickle.dump(results_single_runs_CTR_AdExp, f)            with open(f'../Data/tuning_curve_N_e_signal_ratio/{savename}_results_single_runs_FR_AdExp.pkl', 'wb') as f:                pickle.dump(results_single_runs_FR_AdExp, f)        return results_single_runs_CTR_LIF, results_single_runs_FR_LIF, results_single_runs_CTR_AdExp, results_single_runs_FR_AdExp################################ single run functions ################################def simulate_single_run(R_m, E_L, w_scale, model_mode='AdExp', membrane_noise=1.0):    # run a single CTR-style AdExp simulation and return (time, V_m, spike_times_post)    # input    # R_m is the membrane resistance in MOhm    # E_L is the resting potential in mV    # w_scale is the synaptic scaling factor    # model_mode is a list of strings or string & decides which model is used for simulation    # membrane_noise is the standard deviation of the membrane noise in mV/ms        # output    # time is an array of time stamps in s    # V_m is an array of membrane voltages in mV    # spike_times_post is an array of spike times in s    # (note: uses your exact CTR blocks; no unit conversions beyond your own functions)    # define synaptic input    N_syn, N_e, N_e_signal_ratio, N_i, rate_background_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, mu_weight_e, sigma_weight_e, mu_weight_i, sigma_weight_i = sif.synaptic_parameters(synaptic_scaling_mode='multiplicative')        # orientation variation input    w_e_0, w_i_0, spike_times_e, spike_times_i, r_e, r_i, t_stim, T, N_e_signal, N_e_noise = sif.orientation_variation_input(N_e, N_i, N_e_signal_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, rate_background_ratio,  mu_weight_e, sigma_weight_e, mu_weight_i, sigma_weight_i)    # homogeneous Poisson input    #T = 3100 # ms    #w_e_0, w_i_0, spike_times_e, spike_times_i, r_e, r_i = sif.homogeneous_synaptic_input(T, N_e, N_i, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, mu_weight_e, sigma_weight_e, mu_weight_i, sigma_weight_i)        # scale synaptic input     w_e = w_e_0 * 5 * w_scale * 4    w_i = w_i_0 * 5 * w_scale * 1    # CTR parameters    C_m, E_L_ctr, R_m_ctr, g_L, V_thresh, V_reset, rate_window, E_e, E_i, tau_e, tau_i, Delta_T_ad, tau_w_ad, a_ad, b_ad, sigma_membrane_noise = sim_parameters(parameter_mode='CTR', membrane_noise=membrane_noise)    # override E_L & R_m & dependent g_L & V_reset while keeping the rest as in CTR    E_L = E_L    R_m = R_m    g_L = 10**(3) / R_m    V_reset = E_L    # translate to Brian-readable values    T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_b, w_i_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_b, V_thresh_b, V_reset_b, rate_window_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, sigma_membrane_noise_b = parameters_brian( T, N_e, N_i, spike_times_e, spike_times_i, E_e, E_i, w_e, w_i, tau_e, tau_i, C_m, g_L, E_L, V_thresh, V_reset, rate_window, Delta_T_ad, tau_w_ad, a_ad, b_ad, sigma_membrane_noise)    if 'LIF' in model_mode:        # simulate AdExp        time, V_m, spike_times_post, rate_estimate_post, I_syn_e, I_syn_i, g_e, g_i = LIF(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_b, w_i_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_b, V_thresh_b, V_reset_b, rate_window_b, sigma_membrane_noise_b)    if 'AdExp' in model_mode:        # simulate AdExp        time, V_m, spike_times_post, rate_estimate_post, I_syn_e, I_syn_i, g_e, g_i = AdExp(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_b, w_i_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_b, V_thresh_b, V_reset_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, rate_window_b, sigma_membrane_noise_b)    # optional: run full analysis (not required for the figure, kept here for completeness)    #_ = af.complete_analysis(spike_times_post, V_m, T, R_m, C_m, E_L, I_syn_e, V_thresh, spike_times_e, w_e, N_e_noise)    return time, V_m, spike_times_post, V_threshdef single_CTR_FR_run(model_mode, membrane_noise=0.0, synaptic_scaling_mode='multiplicative'):    # run a single CTR & FR simulation        # input    # model_mode is a list of strings or string & decides which model is used for simulation    # membrane_noise is the standard deviation of the membrane noise in mV/ms    # synaptic_scaling_mode decides if synaptic weight distribution is scaled multiplicatively or non-multiplicatively    # output     # results_LIF, results_AdExp are the results dictionaries    # initialize dictionaries to save results    results_CTR_LIF, results_FR_LIF, results_CTR_AdExp, results_FR_AdExp = {}, {}, {}, {}    # load parameter values    # define synaptic input    if synaptic_scaling_mode == 'multiplicative':         N_syn, N_e, N_e_signal_ratio, N_i, rate_background_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, mu_weight_e, sigma_weight_e, mu_weight_i, sigma_weight_i = sif.synaptic_parameters(synaptic_scaling_mode=synaptic_scaling_mode)                # orientation variation input        w_e_0, w_i_0, spike_times_e, spike_times_i, r_e, r_i, t_stim, T, N_e_signal, N_e_noise = sif.orientation_variation_input(N_e, N_i, N_e_signal_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, rate_background_ratio, mu_weight_e, sigma_weight_e, mu_weight_i, sigma_weight_i)        w_e_0_CTR, w_i_0_CTR, w_e_0_FR, w_i_0_FR = w_e_0, w_i_0, w_e_0, w_i_0            if synaptic_scaling_mode == 'non-multiplicative':         N_syn, N_e, N_e_signal_ratio, N_i, rate_background_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, mu_weight_e_CTR, sigma_weight_e_CTR, mu_weight_i_CTR, sigma_weight_i_CTR, mu_weight_e_FR, sigma_weight_e_FR, mu_weight_i_FR, sigma_weight_i_FR = sif.synaptic_parameters(synaptic_scaling_mode=synaptic_scaling_mode)        w_e_0_CTR, w_i_0_CTR, spike_times_e, spike_times_i, r_e, r_i, t_stim, T, N_e_signal, N_e_noise = sif.orientation_variation_input(N_e, N_i, N_e_signal_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, rate_background_ratio, mu_weight_e_CTR, sigma_weight_e_CTR, mu_weight_i_CTR, sigma_weight_i_CTR)        w_e_0_FR, w_i_0_FR, _, _, _, _, _, _, _, _ = sif.orientation_variation_input(N_e, N_i, N_e_signal_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, rate_background_ratio, mu_weight_e_FR, sigma_weight_e_FR, mu_weight_i_FR, sigma_weight_i_FR)        # load CTR parameter values    C_m, E_L_CTR, R_m_CTR, g_L_CTR, V_thresh, V_reset_CTR, rate_window, E_e, E_i, tau_e, tau_i, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise = sim_parameters(parameter_mode='CTR', membrane_noise=membrane_noise)    # load FR parameter values    C_m, E_L_FR, R_m_FR, g_L_FR, V_thresh, V_reset_FR, rate_window, E_e, E_i, tau_e, tau_i, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise = sim_parameters(parameter_mode='FR', membrane_noise=membrane_noise)    # scale CTR synaptic input    w_scale_CTR = 100 #45    w_e_CTR = w_e_0_CTR * 5 * w_scale_CTR * 4 # low E/I balance: 4/1    w_i_CTR = w_i_0_CTR * 5 * w_scale_CTR * 1 # low E/I balance: 4/1    # scale FR synaptic input    w_scale_FR = w_scale_CTR*0.7    w_e_FR = w_e_0_FR * 5 * w_scale_FR * 4 # low E/I balance: 4/1    w_i_FR = w_i_0_FR * 5 * w_scale_FR * 1 # low E/I balance: 4/1    # translate CTR to Brian-readable values    T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_CTR_b, w_i_CTR_b, tau_e_b, tau_i_b, C_m_b, g_L_CTR_b, E_L_CTR_b, V_thresh_b, V_reset_CTR_b, rate_window_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, membrane_noise_b = parameters_brian(T, N_e, N_i, spike_times_e, spike_times_i, E_e, E_i, w_e_CTR, w_i_CTR, tau_e, tau_i, C_m, g_L_CTR, E_L_CTR, V_thresh, V_reset_CTR, rate_window, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise)        # translate FR to Brian-readable values    T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_FR_b, w_i_FR_b, tau_e_b, tau_i_b, C_m_b, g_L_FR_b, E_L_FR_b, V_thresh_b, V_reset_FR_b, rate_window_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, membrane_noise_b = parameters_brian(T, N_e, N_i, spike_times_e, spike_times_i, E_e, E_i, w_e_FR, w_i_FR, tau_e, tau_i, C_m, g_L_FR, E_L_FR, V_thresh, V_reset_FR, rate_window, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise)        # simulate LIF if given        if 'LIF' in model_mode:                # scale synaptic input        w_e_CTR_LIF_b = w_e_CTR_b        w_i_CTR_LIF_b = w_i_CTR_b        w_e_FR_LIF_b = w_e_FR_b        w_i_FR_LIF_b = w_i_FR_b        # simulate LIF        time_CTR_LIF, V_m_CTR_LIF, spike_times_post_CTR_LIF, rate_estimate_post_CTR_LIF, I_syn_e_CTR_LIF, I_syn_i_CTR_LIF, g_e_CTR_LIF, g_i_CTR_LIF = LIF(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_CTR_LIF_b, w_i_CTR_LIF_b, tau_e_b, tau_i_b, C_m_b, g_L_CTR_b, E_L_CTR_b, V_thresh_b, V_reset_CTR_b, rate_window_b, membrane_noise_b)        time_FR_LIF, V_m_FR_LIF, spike_times_post_FR_LIF, rate_estimate_post_FR_LIF, I_syn_e_FR_LIF, I_syn_i_FR_LIF, g_e_FR_LIF, g_i_FR_LIF = LIF(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_FR_LIF_b, w_i_FR_LIF_b, tau_e_b, tau_i_b, C_m_b, g_L_FR_b, E_L_FR_b, V_thresh_b, V_reset_FR_b, rate_window_b, membrane_noise_b)        # run full LIF analysis        r_post_CTR_LIF, E_tot_CTR_LIF, CV_V_m_CTR_LIF, tuning_curve_CTR_LIF, OSI_CTR_LIF, OSI_per_energy_CTR_LIF, CV_ISI_tuning_curve_CTR_LIF, CV_ISI_tuning_curve_per_energy_CTR_LIF, MI_tuning_curve_CTR_LIF, MI_tuning_curve_per_energy_CTR_LIF, MICE_tuning_curve_CTR_LIF, MICE_tuning_curve_per_energy_CTR_LIF, CV_ISI_CTR_LIF, CV_ISI_per_energy_CTR_LIF, MI_CTR_LIF, MI_per_energy_CTR_LIF, TE_CTR_LIF, TE_per_energy_CTR_LIF, MICE_CTR_LIF, MICE_per_energy_CTR_LIF, TECE_CTR_LIF, TECE_per_energy_CTR_LIF, E_vec_CTR_LIF = af.complete_analysis(spike_times_post_CTR_LIF, V_m_CTR_LIF, T, R_m_CTR, C_m, E_L_CTR, I_syn_e_CTR_LIF, V_thresh, spike_times_e, w_e_CTR, N_e_noise)        r_post_FR_LIF, E_tot_FR_LIF, CV_V_m_FR_LIF, tuning_curve_FR_LIF, OSI_FR_LIF, OSI_per_energy_FR_LIF, CV_ISI_tuning_curve_FR_LIF, CV_ISI_tuning_curve_per_energy_FR_LIF, MI_tuning_curve_FR_LIF, MI_tuning_curve_per_energy_FR_LIF, MICE_tuning_curve_FR_LIF, MICE_tuning_curve_per_energy_FR_LIF, CV_ISI_FR_LIF, CV_ISI_per_energy_FR_LIF, MI_FR_LIF, MI_per_energy_FR_LIF, TE_FR_LIF, TE_per_energy_FR_LIF, MICE_FR_LIF, MICE_per_energy_FR_LIF, TECE_FR_LIF, TECE_per_energy_FR_LIF, E_vec_FR_LIF = af.complete_analysis(spike_times_post_FR_LIF, V_m_FR_LIF, T, R_m_FR, C_m, E_L_FR, I_syn_e_FR_LIF, V_thresh, spike_times_e, w_e_FR, N_e_noise)                      # save CTR results in LIF dictionary         results_CTR_LIF = save_results_dictionary(V_m_CTR_LIF, I_syn_e_CTR_LIF, I_syn_i_CTR_LIF, spike_times_post_CTR_LIF, r_post_CTR_LIF, E_tot_CTR_LIF, CV_V_m_CTR_LIF, tuning_curve_CTR_LIF, OSI_CTR_LIF, OSI_per_energy_CTR_LIF, CV_ISI_tuning_curve_CTR_LIF, CV_ISI_tuning_curve_per_energy_CTR_LIF, MI_tuning_curve_CTR_LIF, MI_tuning_curve_per_energy_CTR_LIF, MICE_tuning_curve_CTR_LIF, MICE_tuning_curve_per_energy_CTR_LIF, CV_ISI_CTR_LIF, CV_ISI_per_energy_CTR_LIF, MI_CTR_LIF, MI_per_energy_CTR_LIF, TE_CTR_LIF, TE_per_energy_CTR_LIF, MICE_CTR_LIF, MICE_per_energy_CTR_LIF, TECE_CTR_LIF, TECE_per_energy_CTR_LIF)        # save FR results in LIF dictionary          results_FR_LIF = save_results_dictionary(V_m_FR_LIF, I_syn_e_FR_LIF, I_syn_i_FR_LIF, spike_times_post_FR_LIF, r_post_FR_LIF, E_tot_FR_LIF, CV_V_m_FR_LIF, tuning_curve_FR_LIF, OSI_FR_LIF, OSI_per_energy_FR_LIF, CV_ISI_tuning_curve_FR_LIF, CV_ISI_tuning_curve_per_energy_FR_LIF, MI_tuning_curve_FR_LIF, MI_tuning_curve_per_energy_FR_LIF, MICE_tuning_curve_FR_LIF, MICE_tuning_curve_per_energy_FR_LIF, CV_ISI_FR_LIF, CV_ISI_per_energy_FR_LIF, MI_FR_LIF, MI_per_energy_FR_LIF, TE_FR_LIF, TE_per_energy_FR_LIF, MICE_FR_LIF, MICE_per_energy_FR_LIF, TECE_FR_LIF, TECE_per_energy_FR_LIF)            # simulate AdExp if given      if 'AdExp' in model_mode:                       # scale synaptic input        weight_factor_LIF_to_AdExp = 1.0 #1.5        w_e_CTR_AdExp_b = w_e_CTR_b * weight_factor_LIF_to_AdExp        w_i_CTR_AdExp_b = w_i_CTR_b * weight_factor_LIF_to_AdExp        w_e_FR_AdExp_b = w_e_FR_b * weight_factor_LIF_to_AdExp        w_i_FR_AdExp_b = w_i_FR_b * weight_factor_LIF_to_AdExp                # simulate AdExp        time_CTR_AdExp, V_m_CTR_AdExp, spike_times_post_CTR_AdExp, rate_estimate_post_CTR_AdExp, I_syn_e_CTR_AdExp, I_syn_i_CTR_AdExp, g_e_CTR_AdExp, g_i_CTR_AdExp = AdExp(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_CTR_AdExp_b, w_i_CTR_AdExp_b, tau_e_b, tau_i_b, C_m_b, g_L_CTR_b, E_L_CTR_b, V_thresh_b, V_reset_CTR_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, rate_window_b, membrane_noise_b)        time_FR_AdExp, V_m_FR_AdExp, spike_times_post_FR_AdExp, rate_estimate_post_FR_AdExp, I_syn_e_FR_AdExp, I_syn_i_FR_AdExp, g_e_FR_AdExp, g_i_FR_AdExp = AdExp(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_FR_AdExp_b, w_i_FR_AdExp_b, tau_e_b, tau_i_b, C_m_b, g_L_FR_b, E_L_FR_b, V_thresh_b, V_reset_FR_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, rate_window_b, membrane_noise_b)                # run full AdExp analysis        r_post_CTR_AdExp, E_tot_CTR_AdExp, CV_V_m_CTR_AdExp, tuning_curve_CTR_AdExp, OSI_CTR_AdExp, OSI_per_energy_CTR_AdExp, CV_ISI_tuning_curve_CTR_AdExp, CV_ISI_tuning_curve_per_energy_CTR_AdExp, MI_tuning_curve_CTR_AdExp, MI_tuning_curve_per_energy_CTR_AdExp, MICE_tuning_curve_CTR_AdExp, MICE_tuning_curve_per_energy_CTR_AdExp, CV_ISI_CTR_AdExp, CV_ISI_per_energy_CTR_AdExp, MI_CTR_AdExp, MI_per_energy_CTR_AdExp, TE_CTR_AdExp, TE_per_energy_CTR_AdExp, MICE_CTR_AdExp, MICE_per_energy_CTR_AdExp, TECE_CTR_AdExp, TECE_per_energy_CTR_AdExp, E_vec_CTR_AdExp = af.complete_analysis(spike_times_post_CTR_AdExp, V_m_CTR_AdExp, T, R_m_CTR, C_m, E_L_CTR, I_syn_e_CTR_AdExp, V_thresh, spike_times_e, w_e_CTR, N_e_noise)        r_post_FR_AdExp, E_tot_FR_AdExp, CV_V_m_FR_AdExp, tuning_curve_FR_AdExp, OSI_FR_AdExp, OSI_per_energy_FR_AdExp, CV_ISI_tuning_curve_FR_AdExp, CV_ISI_tuning_curve_per_energy_FR_AdExp, MI_tuning_curve_FR_AdExp, MI_tuning_curve_per_energy_FR_AdExp, MICE_tuning_curve_FR_AdExp, MICE_tuning_curve_per_energy_FR_AdExp, CV_ISI_FR_AdExp, CV_ISI_per_energy_FR_AdExp, MI_FR_AdExp, MI_per_energy_FR_AdExp, TE_FR_AdExp, TE_per_energy_FR_AdExp, MICE_FR_AdExp, MICE_per_energy_FR_AdExp, TECE_FR_AdExp, TECE_per_energy_FR_AdExp, E_vec_FR_AdExp = af.complete_analysis(spike_times_post_FR_AdExp, V_m_FR_AdExp, T, R_m_FR, C_m, E_L_FR, I_syn_e_FR_AdExp, V_thresh, spike_times_e, w_e_FR, N_e_noise)        # save CTR results in AdExp dictionary         results_CTR_AdExp = save_results_dictionary(V_m_CTR_AdExp, I_syn_e_CTR_AdExp, I_syn_i_CTR_AdExp, spike_times_post_CTR_AdExp, r_post_CTR_AdExp, E_tot_CTR_AdExp, CV_V_m_CTR_AdExp, tuning_curve_CTR_AdExp, OSI_CTR_AdExp, OSI_per_energy_CTR_AdExp, CV_ISI_tuning_curve_CTR_AdExp, CV_ISI_tuning_curve_per_energy_CTR_AdExp, MI_tuning_curve_CTR_AdExp, MI_tuning_curve_per_energy_CTR_AdExp, MICE_tuning_curve_CTR_AdExp, MICE_tuning_curve_per_energy_CTR_AdExp, CV_ISI_CTR_AdExp, CV_ISI_per_energy_CTR_AdExp, MI_CTR_AdExp, MI_per_energy_CTR_AdExp, TE_CTR_AdExp, TE_per_energy_CTR_AdExp, MICE_CTR_AdExp, MICE_per_energy_CTR_AdExp, TECE_CTR_AdExp, TECE_per_energy_CTR_AdExp)        # save FR results in AdExp dictionary         results_FR_AdExp = save_results_dictionary(V_m_FR_AdExp, I_syn_e_FR_AdExp, I_syn_i_FR_AdExp, spike_times_post_FR_AdExp, r_post_FR_AdExp, E_tot_FR_AdExp, CV_V_m_FR_AdExp, tuning_curve_FR_AdExp, OSI_FR_AdExp, OSI_per_energy_FR_AdExp, CV_ISI_tuning_curve_FR_AdExp, CV_ISI_tuning_curve_per_energy_FR_AdExp, MI_tuning_curve_FR_AdExp, MI_tuning_curve_per_energy_FR_AdExp, MICE_tuning_curve_FR_AdExp, MICE_tuning_curve_per_energy_FR_AdExp, CV_ISI_FR_AdExp, CV_ISI_per_energy_FR_AdExp, MI_FR_AdExp, MI_per_energy_FR_AdExp, TE_FR_AdExp, TE_per_energy_FR_AdExp, MICE_FR_AdExp, MICE_per_energy_FR_AdExp, TECE_FR_AdExp, TECE_per_energy_FR_AdExp)            return results_CTR_LIF, results_FR_LIF, results_CTR_AdExp, results_FR_AdExpdef multiple_CTR_FR_runs(number_single_runs, model_mode, membrane_noise=0.0, synaptic_scaling_mode='multiplicative', savename=None):    # run a multiple CTR & FR simulations        # input    # number_single_runs is the number of single runs to perform    # model_mode is a list of strings or string & decides which model is used for simulation    # membrane_noise is the standard deviation of the membrane noise in mV/ms    # synaptic_scaling_mode decides if synaptic weight distribution is scaled multiplicatively or non-multiplicatively    # savename is the name to save the grid as .pkl file    # output     # results_LIF, results_AdExp are the results dictionaries    # initialize dictionaries to save results    results_single_runs_CTR_LIF, results_single_runs_FR_LIF, results_single_runs_CTR_AdExp, results_single_runs_FR_AdExp = empty_results_dictionary(), empty_results_dictionary(), empty_results_dictionary(), empty_results_dictionary()        for _ in range(0, number_single_runs):                 # simulate single run        results_CTR_LIF, results_FR_LIF, results_CTR_AdExp, results_FR_AdExp = single_CTR_FR_run(model_mode=model_mode, membrane_noise=membrane_noise, synaptic_scaling_mode=synaptic_scaling_mode)        for key, value in results_CTR_LIF.items():            results_single_runs_CTR_LIF[key].append(value)                for key, value in results_FR_LIF.items():            results_single_runs_FR_LIF[key].append(value)                for key, value in results_CTR_AdExp.items():            results_single_runs_CTR_AdExp[key].append(value)                for key, value in results_FR_AdExp.items():            results_single_runs_FR_AdExp[key].append(value)        # save results if savename is provided    if savename is not None:        if 'LIF' in model_mode:            with open(f'{savename}_results_single_runs_CTR_LIF.pkl', 'wb') as f:                pickle.dump(results_single_runs_CTR_LIF, f)            with open(f'{savename}_results_single_runs_FR_LIF.pkl', 'wb') as f:                pickle.dump(results_single_runs_FR_LIF, f)        if 'AdExp' in model_mode:            with open(f'{savename}_results_single_runs_CTR_AdExp.pkl', 'wb') as f:                pickle.dump(results_single_runs_CTR_AdExp, f)            with open(f'{savename}_results_single_runs_FR_AdExp.pkl', 'wb') as f:                pickle.dump(results_single_runs_FR_AdExp, f)        return results_single_runs_CTR_LIF, results_single_runs_FR_LIF, results_single_runs_CTR_AdExp, results_single_runs_FR_AdExp########################################### effect of adaptation and exponential term runs ####################################################################################def single_CTR_FR_ad_or_exp_run(membrane_noise=0.0, synaptic_scaling_mode='multiplicative'):    # run a single CTR & FR simulations to determine whether adaptation or exponential part is enabling tuning curve broadening        # input    # membrane_noise is the standard deviation of the membrane noise in mV/ms    # synaptic_scaling_mode decides if synaptic weight distribution is scaled multiplicatively or non-multiplicatively    # output     # results_LIF, results_LIF_exp, results_LIF_ad, results_AdExp are the results dictionaries    # initialize dictionaries to save results    results_CTR_LIF, results_FR_LIF, results_CTR_LIFexp, results_FR_LIFexp, results_CTR_LIFad, results_FR_LIFad, results_CTR_AdExp, results_FR_AdExp = {}, {}, {}, {}, {}, {}, {}, {}    # load parameter values    # define synaptic input    if synaptic_scaling_mode == 'multiplicative':         N_syn, N_e, N_e_signal_ratio, N_i, rate_background_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, mu_weight_e, sigma_weight_e, mu_weight_i, sigma_weight_i = sif.synaptic_parameters(synaptic_scaling_mode=synaptic_scaling_mode)                # orientation variation input        w_e_0, w_i_0, spike_times_e, spike_times_i, r_e, r_i, t_stim, T, N_e_signal, N_e_noise = sif.orientation_variation_input(N_e, N_i, N_e_signal_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, rate_background_ratio, mu_weight_e, sigma_weight_e, mu_weight_i, sigma_weight_i)        w_e_0_CTR, w_i_0_CTR, w_e_0_FR, w_i_0_FR = w_e_0, w_i_0, w_e_0, w_i_0            if synaptic_scaling_mode == 'non-multiplicative':         N_syn, N_e, N_e_signal_ratio, N_i, rate_background_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, mu_weight_e_CTR, sigma_weight_e_CTR, mu_weight_i_CTR, sigma_weight_i_CTR, mu_weight_e_FR, sigma_weight_e_FR, mu_weight_i_FR, sigma_weight_i_FR = sif.synaptic_parameters(synaptic_scaling_mode=synaptic_scaling_mode)        w_e_0_CTR, w_i_0_CTR, spike_times_e, spike_times_i, r_e, r_i, t_stim, T, N_e_signal, N_e_noise = sif.orientation_variation_input(N_e, N_i, N_e_signal_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, rate_background_ratio, mu_weight_e_CTR, sigma_weight_e_CTR, mu_weight_i_CTR, sigma_weight_i_CTR)        w_e_0_FR, w_i_0_FR, _, _, _, _, _, _, _, _ = sif.orientation_variation_input(N_e, N_i, N_e_signal_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, rate_background_ratio, mu_weight_e_FR, sigma_weight_e_FR, mu_weight_i_FR, sigma_weight_i_FR)        # load CTR parameter values    C_m, E_L_CTR, R_m_CTR, g_L_CTR, V_thresh, V_reset_CTR, rate_window, E_e, E_i, tau_e, tau_i, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise = sim_parameters(parameter_mode='CTR', membrane_noise=membrane_noise)    # load FR parameter values    C_m, E_L_FR, R_m_FR, g_L_FR, V_thresh, V_reset_FR, rate_window, E_e, E_i, tau_e, tau_i, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise = sim_parameters(parameter_mode='FR', membrane_noise=membrane_noise)    # scale CTR synaptic input    w_scale_CTR = 110    w_e_CTR = w_e_0_CTR * 5 * w_scale_CTR * 4 # low E/I balance: 4/1    w_i_CTR = w_i_0_CTR * 5 * w_scale_CTR * 1 # low E/I balance: 4/1    # scale FR synaptic input    w_scale_FR = w_scale_CTR*0.65    w_e_FR = w_e_0_FR * 5 * w_scale_FR * 4 # low E/I balance: 4/1    w_i_FR = w_i_0_FR * 5 * w_scale_FR * 1 # low E/I balance: 4/1    # translate CTR to Brian-readable values    T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_CTR_b, w_i_CTR_b, tau_e_b, tau_i_b, C_m_b, g_L_CTR_b, E_L_CTR_b, V_thresh_b, V_reset_CTR_b, rate_window_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, membrane_noise_b = parameters_brian(T, N_e, N_i, spike_times_e, spike_times_i, E_e, E_i, w_e_CTR, w_i_CTR, tau_e, tau_i, C_m, g_L_CTR, E_L_CTR, V_thresh, V_reset_CTR, rate_window, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise)        # translate FR to Brian-readable values    T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_FR_b, w_i_FR_b, tau_e_b, tau_i_b, C_m_b, g_L_FR_b, E_L_FR_b, V_thresh_b, V_reset_FR_b, rate_window_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, membrane_noise_b = parameters_brian(T, N_e, N_i, spike_times_e, spike_times_i, E_e, E_i, w_e_FR, w_i_FR, tau_e, tau_i, C_m, g_L_FR, E_L_FR, V_thresh, V_reset_FR, rate_window, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise)    # -------------------------- I) simulate LIF --------------------------    # scale synaptic input    w_e_CTR_LIF_b = w_e_CTR_b    w_i_CTR_LIF_b = w_i_CTR_b    w_e_FR_LIF_b = w_e_FR_b    w_i_FR_LIF_b = w_i_FR_b    # simulate LIF    time_CTR_LIF, V_m_CTR_LIF, spike_times_post_CTR_LIF, rate_estimate_post_CTR_LIF, I_syn_e_CTR_LIF, I_syn_i_CTR_LIF, g_e_CTR_LIF, g_i_CTR_LIF = LIF(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_CTR_LIF_b, w_i_CTR_LIF_b, tau_e_b, tau_i_b, C_m_b, g_L_CTR_b, E_L_CTR_b, V_thresh_b, V_reset_CTR_b, rate_window_b, membrane_noise_b)    time_FR_LIF, V_m_FR_LIF, spike_times_post_FR_LIF, rate_estimate_post_FR_LIF, I_syn_e_FR_LIF, I_syn_i_FR_LIF, g_e_FR_LIF, g_i_FR_LIF = LIF(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_FR_LIF_b, w_i_FR_LIF_b, tau_e_b, tau_i_b, C_m_b, g_L_FR_b, E_L_FR_b, V_thresh_b, V_reset_FR_b, rate_window_b, membrane_noise_b)    # run full LIF analysis    r_post_CTR_LIF, E_tot_CTR_LIF, CV_V_m_CTR_LIF, tuning_curve_CTR_LIF, OSI_CTR_LIF, OSI_per_energy_CTR_LIF, CV_ISI_tuning_curve_CTR_LIF, CV_ISI_tuning_curve_per_energy_CTR_LIF, MI_tuning_curve_CTR_LIF, MI_tuning_curve_per_energy_CTR_LIF, MICE_tuning_curve_CTR_LIF, MICE_tuning_curve_per_energy_CTR_LIF, CV_ISI_CTR_LIF, CV_ISI_per_energy_CTR_LIF, MI_CTR_LIF, MI_per_energy_CTR_LIF, TE_CTR_LIF, TE_per_energy_CTR_LIF, MICE_CTR_LIF, MICE_per_energy_CTR_LIF, TECE_CTR_LIF, TECE_per_energy_CTR_LIF, E_vec_CTR_LIF = af.complete_analysis(spike_times_post_CTR_LIF, V_m_CTR_LIF, T, R_m_CTR, C_m, E_L_CTR, I_syn_e_CTR_LIF, V_thresh, spike_times_e, w_e_CTR, N_e_noise)    r_post_FR_LIF, E_tot_FR_LIF, CV_V_m_FR_LIF, tuning_curve_FR_LIF, OSI_FR_LIF, OSI_per_energy_FR_LIF, CV_ISI_tuning_curve_FR_LIF, CV_ISI_tuning_curve_per_energy_FR_LIF, MI_tuning_curve_FR_LIF, MI_tuning_curve_per_energy_FR_LIF, MICE_tuning_curve_FR_LIF, MICE_tuning_curve_per_energy_FR_LIF, CV_ISI_FR_LIF, CV_ISI_per_energy_FR_LIF, MI_FR_LIF, MI_per_energy_FR_LIF, TE_FR_LIF, TE_per_energy_FR_LIF, MICE_FR_LIF, MICE_per_energy_FR_LIF, TECE_FR_LIF, TECE_per_energy_FR_LIF, E_vec_FR_LIF = af.complete_analysis(spike_times_post_FR_LIF, V_m_FR_LIF, T, R_m_FR, C_m, E_L_FR, I_syn_e_FR_LIF, V_thresh, spike_times_e, w_e_FR, N_e_noise)              # save CTR results in LIF dictionary     results_CTR_LIF = save_results_dictionary(V_m_CTR_LIF, I_syn_e_CTR_LIF, I_syn_i_CTR_LIF, spike_times_post_CTR_LIF, r_post_CTR_LIF, E_tot_CTR_LIF, CV_V_m_CTR_LIF, tuning_curve_CTR_LIF, OSI_CTR_LIF, OSI_per_energy_CTR_LIF, CV_ISI_tuning_curve_CTR_LIF, CV_ISI_tuning_curve_per_energy_CTR_LIF, MI_tuning_curve_CTR_LIF, MI_tuning_curve_per_energy_CTR_LIF, MICE_tuning_curve_CTR_LIF, MICE_tuning_curve_per_energy_CTR_LIF, CV_ISI_CTR_LIF, CV_ISI_per_energy_CTR_LIF, MI_CTR_LIF, MI_per_energy_CTR_LIF, TE_CTR_LIF, TE_per_energy_CTR_LIF, MICE_CTR_LIF, MICE_per_energy_CTR_LIF, TECE_CTR_LIF, TECE_per_energy_CTR_LIF)    # save FR results in LIF dictionary      results_FR_LIF = save_results_dictionary(V_m_FR_LIF, I_syn_e_FR_LIF, I_syn_i_FR_LIF, spike_times_post_FR_LIF, r_post_FR_LIF, E_tot_FR_LIF, CV_V_m_FR_LIF, tuning_curve_FR_LIF, OSI_FR_LIF, OSI_per_energy_FR_LIF, CV_ISI_tuning_curve_FR_LIF, CV_ISI_tuning_curve_per_energy_FR_LIF, MI_tuning_curve_FR_LIF, MI_tuning_curve_per_energy_FR_LIF, MICE_tuning_curve_FR_LIF, MICE_tuning_curve_per_energy_FR_LIF, CV_ISI_FR_LIF, CV_ISI_per_energy_FR_LIF, MI_FR_LIF, MI_per_energy_FR_LIF, TE_FR_LIF, TE_per_energy_FR_LIF, MICE_FR_LIF, MICE_per_energy_FR_LIF, TECE_FR_LIF, TECE_per_energy_FR_LIF)    # -------------------------- II) simulate LIF + exp term --------------------------        def LIFexp(T, N_e, N_i, spike_times_e, spike_times_i, E_e, E_i, w_e, w_i, tau_e, tau_i, C_m, g_L, E_L, V_thresh, V_reset, Delta_T, rate_window, membrane_noise):        # simulation LIF model                # input        # T is the duration of the simulation in ms        # N_e is the number of excitatory synaptic inputs        # N_i is the number of inhibitory synaptic inputs        # spike_times_e is an array of excitatory input spike trains        # spike_times_i is an array of inhibitory input spike trains        # E_e is the reversal potential for excitatory inputs in mV        # E_i is the reversal potential for inhibitory inputs in mV        # w_e are the weights of exc. input        # w_i are the weights of inh. input        # tau_e is the postsynaptic potential (PSP) time constant for exc. input in ms        # tau_i is the postsynaptic potential (PSP) time constant for inh. input in ms        # C_m is the membrane capacitance in pF        # g_L is the leak conductance in nS        # E_L is the resting potential (leak reversal potential) / mV        # V_thresh is the spike generation threshold in mV        # V_reset is the reset potential in mV        # Delta_T is the slope factor in mV        # rate_window is the integration time for the online firing-rate estimation in ms        # membrane_noise is the standard deviation of the membrane noise in mV/ms            # output         # time is an array of length n of the time        # V_m is an array of length n of the membrane voltage        # spike_times_post is a list of postsynaptic spike times        # rate_estimate_post  is an array of length n of instantaneous firing rates        # I_syn_e is an array of length n of excitatory synaptic current        # I_syn_i is an array of length n of inhibitory synaptic current        # g_e is an array of length n of excitatory conductances        # g_i is an array of length n of inhibitory conductances                start_scope()        #defaultclock.dt = dt*ms                N = 1  # number of postsynaptic neurons        # define V_T & spiking threshold        V_T = V_thresh - 2.5 * Delta_T        V_thresh_spike_detection = V_thresh + 2.5 * Delta_T                if membrane_noise == 0.0:             eqs = '''            dV_m/dt = (g_L*(E_L-V_m) + g_L*Delta_T*exp((V_m - V_T)/Delta_T) + I_syn_e + I_syn_i) / C_m : volt            I_syn_e = g_e*(E_e-V_m) : amp            I_syn_i = g_i*(E_i-V_m) : amp            dg_e/dt = -g_e/tau_e : siemens            dg_i/dt = -g_i/tau_i : siemens            '''            neuron = NeuronGroup(N, model=eqs, threshold='V_m > V_thresh_spike_detection', reset='V_m = V_reset', method='exponential_euler')            neuron.V_m = V_reset                    if membrane_noise > 0.0:             eqs = '''            dV_m/dt = (g_L*(E_L-V_m) + g_L*Delta_T*exp((V_m - V_T)/Delta_T) + I_syn_e + I_syn_i) / C_m + membrane_noise*xi*sqrt(dt) : volt            I_syn_e = g_e*(E_e-V_m) : amp            I_syn_i = g_i*(E_i-V_m) : amp            dg_e/dt = -g_e/tau_e : siemens            dg_i/dt = -g_i/tau_i : siemens            '''            # for temporally correlated noise multiply noise term with * sqrt(2/tau_noise) with tau_noise=5–50 ms                        neuron = NeuronGroup(N, model=eqs, threshold='V_m > V_thresh_spike_detection', reset='V_m = V_reset', method='euler')            neuron.V_m = V_reset                # convert spike_times_e and spike_times_i to SpikeGeneratorGroup format        indices_e, times_e = zip(*[(i, spike) for i, spikes in spike_times_e.items() for spike in spikes])        indices_i, times_i = zip(*[(i, spike) for i, spikes in spike_times_i.items() for spike in spikes])            G_e = SpikeGeneratorGroup(N_e, indices_e, times_e)        G_i = SpikeGeneratorGroup(N_i, indices_i, times_i)            exc_synapses = Synapses(G_e, neuron, 'w: siemens', on_pre='g_e += w')        exc_synapses.connect()        for i, weight in enumerate(w_e):            exc_synapses.w[i] = weight            inh_synapses = Synapses(G_i, neuron, 'w: siemens', on_pre='g_i += w')        inh_synapses.connect()        for i, weight in enumerate(w_i):            inh_synapses.w[i] = weight            spikes = SpikeMonitor(neuron)        rate_monitor = PopulationRateMonitor(neuron)        post_states = StateMonitor(neuron, ('V_m', 'I_syn_e', 'I_syn_i', 'g_e', 'g_i'), record=True)                run(T, report='text')            time = post_states.t / second        V_m = post_states.V_m[0] / mV        spike_times_post = spikes.t / ms        rate_estimate_post = rate_monitor.smooth_rate(window='flat', width=rate_window) / Hz # alternative window mode 'gaussian'        I_syn_e = post_states.I_syn_e[0] / nA        I_syn_i = post_states.I_syn_i[0] / nA        g_e = post_states.g_e[0] / nS        g_i = post_states.g_i[0] / nS                return time, V_m, spike_times_post, rate_estimate_post, I_syn_e, I_syn_i, g_e, g_i            # scale synaptic input    weight_factor_LIF_to_LIFexp = 0.7    w_e_CTR_LIFexp_b = w_e_CTR_b * weight_factor_LIF_to_LIFexp    w_i_CTR_LIFexp_b = w_i_CTR_b * weight_factor_LIF_to_LIFexp    w_e_FR_LIFexp_b = w_e_FR_b * weight_factor_LIF_to_LIFexp    w_i_FR_LIFexp_b = w_i_FR_b * weight_factor_LIF_to_LIFexp    # simulate LIFexp    time_CTR_LIFexp, V_m_CTR_LIFexp, spike_times_post_CTR_LIFexp, rate_estimate_post_CTR_LIFexp, I_syn_e_CTR_LIFexp, I_syn_i_CTR_LIFexp, g_e_CTR_LIFexp, g_i_CTR_LIFexp = LIFexp(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_CTR_LIFexp_b, w_i_CTR_LIFexp_b, tau_e_b, tau_i_b, C_m_b, g_L_CTR_b, E_L_CTR_b, V_thresh_b, V_reset_CTR_b, Delta_T_ad_b, rate_window_b, membrane_noise_b)    time_FR_LIFexp, V_m_FR_LIFexp, spike_times_post_FR_LIFexp, rate_estimate_post_FR_LIFexp, I_syn_e_FR_LIFexp, I_syn_i_FR_LIFexp, g_e_FR_LIFexp, g_i_FR_LIFexp = LIFexp(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_FR_LIFexp_b, w_i_FR_LIFexp_b, tau_e_b, tau_i_b, C_m_b, g_L_FR_b, E_L_FR_b, V_thresh_b, V_reset_FR_b, Delta_T_ad_b, rate_window_b, membrane_noise_b)    # run full LIFexp analysis    r_post_CTR_LIFexp, E_tot_CTR_LIFexp, CV_V_m_CTR_LIFexp, tuning_curve_CTR_LIFexp, OSI_CTR_LIFexp, OSI_per_energy_CTR_LIFexp, CV_ISI_tuning_curve_CTR_LIFexp, CV_ISI_tuning_curve_per_energy_CTR_LIFexp, MI_tuning_curve_CTR_LIFexp, MI_tuning_curve_per_energy_CTR_LIFexp, MICE_tuning_curve_CTR_LIFexp, MICE_tuning_curve_per_energy_CTR_LIFexp, CV_ISI_CTR_LIFexp, CV_ISI_per_energy_CTR_LIFexp, MI_CTR_LIFexp, MI_per_energy_CTR_LIFexp, TE_CTR_LIFexp, TE_per_energy_CTR_LIFexp, MICE_CTR_LIFexp, MICE_per_energy_CTR_LIFexp, TECE_CTR_LIFexp, TECE_per_energy_CTR_LIFexp, E_vec_CTR_LIFexp = af.complete_analysis(spike_times_post_CTR_LIFexp, V_m_CTR_LIFexp, T, R_m_CTR, C_m, E_L_CTR, I_syn_e_CTR_LIFexp, V_thresh, spike_times_e, w_e_CTR, N_e_noise)    r_post_FR_LIFexp, E_tot_FR_LIFexp, CV_V_m_FR_LIFexp, tuning_curve_FR_LIFexp, OSI_FR_LIFexp, OSI_per_energy_FR_LIFexp, CV_ISI_tuning_curve_FR_LIFexp, CV_ISI_tuning_curve_per_energy_FR_LIFexp, MI_tuning_curve_FR_LIFexp, MI_tuning_curve_per_energy_FR_LIFexp, MICE_tuning_curve_FR_LIFexp, MICE_tuning_curve_per_energy_FR_LIFexp, CV_ISI_FR_LIFexp, CV_ISI_per_energy_FR_LIFexp, MI_FR_LIFexp, MI_per_energy_FR_LIFexp, TE_FR_LIFexp, TE_per_energy_FR_LIFexp, MICE_FR_LIFexp, MICE_per_energy_FR_LIFexp, TECE_FR_LIFexp, TECE_per_energy_FR_LIFexp, E_vec_FR_LIFexp = af.complete_analysis(spike_times_post_FR_LIFexp, V_m_FR_LIFexp, T, R_m_FR, C_m, E_L_FR, I_syn_e_FR_LIFexp, V_thresh, spike_times_e, w_e_FR, N_e_noise)              # save CTR results in LIFexp dictionary     results_CTR_LIFexp = save_results_dictionary(V_m_CTR_LIFexp, I_syn_e_CTR_LIFexp, I_syn_i_CTR_LIFexp, spike_times_post_CTR_LIFexp, r_post_CTR_LIFexp, E_tot_CTR_LIFexp, CV_V_m_CTR_LIFexp, tuning_curve_CTR_LIFexp, OSI_CTR_LIFexp, OSI_per_energy_CTR_LIFexp, CV_ISI_tuning_curve_CTR_LIFexp, CV_ISI_tuning_curve_per_energy_CTR_LIFexp, MI_tuning_curve_CTR_LIFexp, MI_tuning_curve_per_energy_CTR_LIFexp, MICE_tuning_curve_CTR_LIFexp, MICE_tuning_curve_per_energy_CTR_LIFexp, CV_ISI_CTR_LIFexp, CV_ISI_per_energy_CTR_LIFexp, MI_CTR_LIFexp, MI_per_energy_CTR_LIFexp, TE_CTR_LIFexp, TE_per_energy_CTR_LIFexp, MICE_CTR_LIFexp, MICE_per_energy_CTR_LIFexp, TECE_CTR_LIFexp, TECE_per_energy_CTR_LIFexp)    # save FR results in LIFexp dictionary      results_FR_LIFexp = save_results_dictionary(V_m_FR_LIFexp, I_syn_e_FR_LIFexp, I_syn_i_FR_LIFexp, spike_times_post_FR_LIFexp, r_post_FR_LIFexp, E_tot_FR_LIFexp, CV_V_m_FR_LIFexp, tuning_curve_FR_LIFexp, OSI_FR_LIFexp, OSI_per_energy_FR_LIFexp, CV_ISI_tuning_curve_FR_LIFexp, CV_ISI_tuning_curve_per_energy_FR_LIFexp, MI_tuning_curve_FR_LIFexp, MI_tuning_curve_per_energy_FR_LIFexp, MICE_tuning_curve_FR_LIFexp, MICE_tuning_curve_per_energy_FR_LIFexp, CV_ISI_FR_LIFexp, CV_ISI_per_energy_FR_LIFexp, MI_FR_LIFexp, MI_per_energy_FR_LIFexp, TE_FR_LIFexp, TE_per_energy_FR_LIFexp, MICE_FR_LIFexp, MICE_per_energy_FR_LIFexp, TECE_FR_LIFexp, TECE_per_energy_FR_LIFexp)        # -------------------------- III) simulate LIF + ad term --------------------------    def LIFad(T, N_e, N_i, spike_times_e, spike_times_i, E_e, E_i, w_e, w_i, tau_e, tau_i, C_m, g_L, E_L, V_thresh, V_reset, tau_w, a, b, rate_window, membrane_noise):        # simulation LIF model                # input        # T is the duration of the simulation in ms        # N_e is the number of excitatory synaptic inputs        # N_i is the number of inhibitory synaptic inputs        # spike_times_e is an array of excitatory input spike trains        # spike_times_i is an array of inhibitory input spike trains        # E_e is the reversal potential for excitatory inputs in mV        # E_i is the reversal potential for inhibitory inputs in mV        # w_e are the weights of exc. input        # w_i are the weights of inh. input        # tau_e is the postsynaptic potential (PSP) time constant for exc. input in ms        # tau_i is the postsynaptic potential (PSP) time constant for inh. input in ms        # C_m is the membrane capacitance in pF        # g_L is the leak conductance in nS        # E_L is the resting potential (leak reversal potential) / mV        # V_thresh is the spike generation threshold in mV        # V_reset is the reset potential in mV        # tau_w is the adaptation time constant in ms        # a is the subthreshold adaptation in nS        # b is the spike-triggered adaptation in pA        # rate_window is the integration time for the online firing-rate estimation in ms        # membrane_noise is the standard deviation of the membrane noise in mV/ms            # output         # time is an array of length n of the time        # V_m is an array of length n of the membrane voltage        # spike_times_post is a list of postsynaptic spike times        # rate_estimate_post  is an array of length n of instantaneous firing rates        # I_syn_e is an array of length n of excitatory synaptic current        # I_syn_i is an array of length n of inhibitory synaptic current        # g_e is an array of length n of excitatory conductances        # g_i is an array of length n of inhibitory conductances                #defaultclock.dt = dt*ms        start_scope()                N = 1  # number of postsynaptic neurons                if membrane_noise == 0.0:             eqs = '''            dV_m/dt = (g_L*(E_L-V_m) - w_ad + I_syn_e + I_syn_i) / C_m : volt            dw_ad/dt = (a*(V_m - E_L) - w_ad) / tau_w : amp            I_syn_e = g_e*(E_e-V_m) : amp            I_syn_i = g_i*(E_i-V_m) : amp            dg_e/dt = -g_e/tau_e : siemens            dg_i/dt = -g_i/tau_i : siemens            '''                        neuron = NeuronGroup(N, model=eqs, threshold='V_m > V_thresh', reset='V_m = V_reset', method='rk4')            neuron.V_m = V_reset                    if membrane_noise > 0.0:             eqs = '''            dV_m/dt = (g_L*(E_L-V_m) - w_ad + I_syn_e + I_syn_i) / C_m + membrane_noise*xi*sqrt(dt) : volt            dw_ad/dt = (a*(V_m - E_L) - w_ad) / tau_w : amp            I_syn_e = g_e*(E_e-V_m) : amp            I_syn_i = g_i*(E_i-V_m) : amp            dg_e/dt = -g_e/tau_e : siemens            dg_i/dt = -g_i/tau_i : siemens            '''            # for temporally correlated noise multiply noise term with * sqrt(2/tau_noise) with tau_noise=5–50 ms                        neuron = NeuronGroup(N, model=eqs, threshold='V_m > V_thresh', reset='V_m = V_reset', method='euler')            neuron.V_m = V_reset                # convert spike_times_e and spike_times_i to SpikeGeneratorGroup format        indices_e, times_e = zip(*[(i, spike) for i, spikes in spike_times_e.items() for spike in spikes])        indices_i, times_i = zip(*[(i, spike) for i, spikes in spike_times_i.items() for spike in spikes])            G_e = SpikeGeneratorGroup(N_e, indices_e, times_e)        G_i = SpikeGeneratorGroup(N_i, indices_i, times_i)            exc_synapses = Synapses(G_e, neuron, 'w: siemens', on_pre='g_e += w')        exc_synapses.connect()        for i, weight in enumerate(w_e):            exc_synapses.w[i] = weight            inh_synapses = Synapses(G_i, neuron, 'w: siemens', on_pre='g_i += w')        inh_synapses.connect()        for i, weight in enumerate(w_i):            inh_synapses.w[i] = weight            spikes = SpikeMonitor(neuron)        rate_monitor = PopulationRateMonitor(neuron)        post_states = StateMonitor(neuron, ('V_m', 'I_syn_e', 'I_syn_i', 'g_e', 'g_i'), record=True)                run(T, report='text')            time = post_states.t / second        V_m = post_states.V_m[0] / mV        spike_times_post = spikes.t / ms        rate_estimate_post = rate_monitor.smooth_rate(window='flat', width=rate_window) / Hz # alternative window mode 'gaussian'        I_syn_e = post_states.I_syn_e[0] / nA        I_syn_i = post_states.I_syn_i[0] / nA        g_e = post_states.g_e[0] / nS        g_i = post_states.g_i[0] / nS                return time, V_m, spike_times_post, rate_estimate_post, I_syn_e, I_syn_i, g_e, g_i        # scale synaptic input    weight_factor_LIF_to_LIFad = 1.3    w_e_CTR_LIFad_b = w_e_CTR_b * weight_factor_LIF_to_LIFad    w_i_CTR_LIFad_b = w_i_CTR_b * weight_factor_LIF_to_LIFad    w_e_FR_LIFad_b = w_e_FR_b * weight_factor_LIF_to_LIFad    w_i_FR_LIFad_b = w_i_FR_b * weight_factor_LIF_to_LIFad    # simulate LIFad    time_CTR_LIFad, V_m_CTR_LIFad, spike_times_post_CTR_LIFad, rate_estimate_post_CTR_LIFad, I_syn_e_CTR_LIFad, I_syn_i_CTR_LIFad, g_e_CTR_LIFad, g_i_CTR_LIFad = LIFad(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_CTR_LIFad_b, w_i_CTR_LIFad_b, tau_e_b, tau_i_b, C_m_b, g_L_CTR_b, E_L_CTR_b, V_thresh_b, V_reset_CTR_b, tau_w_ad_b, a_ad_b, b_ad_b, rate_window_b, membrane_noise_b)    time_FR_LIFad, V_m_FR_LIFad, spike_times_post_FR_LIFad, rate_estimate_post_FR_LIFad, I_syn_e_FR_LIFad, I_syn_i_FR_LIFad, g_e_FR_LIFad, g_i_FR_LIFad = LIFad(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_FR_LIFad_b, w_i_FR_LIFad_b, tau_e_b, tau_i_b, C_m_b, g_L_FR_b, E_L_FR_b, V_thresh_b, V_reset_FR_b, tau_w_ad_b, a_ad_b, b_ad_b, rate_window_b, membrane_noise_b)    # run full LIFad analysis    r_post_CTR_LIFad, E_tot_CTR_LIFad, CV_V_m_CTR_LIFad, tuning_curve_CTR_LIFad, OSI_CTR_LIFad, OSI_per_energy_CTR_LIFad, CV_ISI_tuning_curve_CTR_LIFad, CV_ISI_tuning_curve_per_energy_CTR_LIFad, MI_tuning_curve_CTR_LIFad, MI_tuning_curve_per_energy_CTR_LIFad, MICE_tuning_curve_CTR_LIFad, MICE_tuning_curve_per_energy_CTR_LIFad, CV_ISI_CTR_LIFad, CV_ISI_per_energy_CTR_LIFad, MI_CTR_LIFad, MI_per_energy_CTR_LIFad, TE_CTR_LIFad, TE_per_energy_CTR_LIFad, MICE_CTR_LIFad, MICE_per_energy_CTR_LIFad, TECE_CTR_LIFad, TECE_per_energy_CTR_LIFad, E_vec_CTR_LIFad = af.complete_analysis(spike_times_post_CTR_LIFad, V_m_CTR_LIFad, T, R_m_CTR, C_m, E_L_CTR, I_syn_e_CTR_LIFad, V_thresh, spike_times_e, w_e_CTR, N_e_noise)    r_post_FR_LIFad, E_tot_FR_LIFad, CV_V_m_FR_LIFad, tuning_curve_FR_LIFad, OSI_FR_LIFad, OSI_per_energy_FR_LIFad, CV_ISI_tuning_curve_FR_LIFad, CV_ISI_tuning_curve_per_energy_FR_LIFad, MI_tuning_curve_FR_LIFad, MI_tuning_curve_per_energy_FR_LIFad, MICE_tuning_curve_FR_LIFad, MICE_tuning_curve_per_energy_FR_LIFad, CV_ISI_FR_LIFad, CV_ISI_per_energy_FR_LIFad, MI_FR_LIFad, MI_per_energy_FR_LIFad, TE_FR_LIFad, TE_per_energy_FR_LIFad, MICE_FR_LIFad, MICE_per_energy_FR_LIFad, TECE_FR_LIFad, TECE_per_energy_FR_LIFad, E_vec_FR_LIFad = af.complete_analysis(spike_times_post_FR_LIFad, V_m_FR_LIFad, T, R_m_FR, C_m, E_L_FR, I_syn_e_FR_LIFad, V_thresh, spike_times_e, w_e_FR, N_e_noise)              # save CTR results in LIFad dictionary     results_CTR_LIFad = save_results_dictionary(V_m_CTR_LIFad, I_syn_e_CTR_LIFad, I_syn_i_CTR_LIFad, spike_times_post_CTR_LIFad, r_post_CTR_LIFad, E_tot_CTR_LIFad, CV_V_m_CTR_LIFad, tuning_curve_CTR_LIFad, OSI_CTR_LIFad, OSI_per_energy_CTR_LIFad, CV_ISI_tuning_curve_CTR_LIFad, CV_ISI_tuning_curve_per_energy_CTR_LIFad, MI_tuning_curve_CTR_LIFad, MI_tuning_curve_per_energy_CTR_LIFad, MICE_tuning_curve_CTR_LIFad, MICE_tuning_curve_per_energy_CTR_LIFad, CV_ISI_CTR_LIFad, CV_ISI_per_energy_CTR_LIFad, MI_CTR_LIFad, MI_per_energy_CTR_LIFad, TE_CTR_LIFad, TE_per_energy_CTR_LIFad, MICE_CTR_LIFad, MICE_per_energy_CTR_LIFad, TECE_CTR_LIFad, TECE_per_energy_CTR_LIFad)    # save FR results in LIFad dictionary      results_FR_LIFad = save_results_dictionary(V_m_FR_LIFad, I_syn_e_FR_LIFad, I_syn_i_FR_LIFad, spike_times_post_FR_LIFad, r_post_FR_LIFad, E_tot_FR_LIFad, CV_V_m_FR_LIFad, tuning_curve_FR_LIFad, OSI_FR_LIFad, OSI_per_energy_FR_LIFad, CV_ISI_tuning_curve_FR_LIFad, CV_ISI_tuning_curve_per_energy_FR_LIFad, MI_tuning_curve_FR_LIFad, MI_tuning_curve_per_energy_FR_LIFad, MICE_tuning_curve_FR_LIFad, MICE_tuning_curve_per_energy_FR_LIFad, CV_ISI_FR_LIFad, CV_ISI_per_energy_FR_LIFad, MI_FR_LIFad, MI_per_energy_FR_LIFad, TE_FR_LIFad, TE_per_energy_FR_LIFad, MICE_FR_LIFad, MICE_per_energy_FR_LIFad, TECE_FR_LIFad, TECE_per_energy_FR_LIFad)    # -------------------------- IV) simulate AdExp --------------------------        # scale synaptic input    weight_factor_LIF_to_AdExp = 0.9    w_e_CTR_AdExp_b = w_e_CTR_b * weight_factor_LIF_to_AdExp    w_i_CTR_AdExp_b = w_i_CTR_b * weight_factor_LIF_to_AdExp    w_e_FR_AdExp_b = w_e_FR_b * weight_factor_LIF_to_AdExp    w_i_FR_AdExp_b = w_i_FR_b * weight_factor_LIF_to_AdExp        # simulate AdExp    time_CTR_AdExp, V_m_CTR_AdExp, spike_times_post_CTR_AdExp, rate_estimate_post_CTR_AdExp, I_syn_e_CTR_AdExp, I_syn_i_CTR_AdExp, g_e_CTR_AdExp, g_i_CTR_AdExp = AdExp(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_CTR_AdExp_b, w_i_CTR_AdExp_b, tau_e_b, tau_i_b, C_m_b, g_L_CTR_b, E_L_CTR_b, V_thresh_b, V_reset_CTR_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, rate_window_b, membrane_noise_b)    time_FR_AdExp, V_m_FR_AdExp, spike_times_post_FR_AdExp, rate_estimate_post_FR_AdExp, I_syn_e_FR_AdExp, I_syn_i_FR_AdExp, g_e_FR_AdExp, g_i_FR_AdExp = AdExp(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_FR_AdExp_b, w_i_FR_AdExp_b, tau_e_b, tau_i_b, C_m_b, g_L_FR_b, E_L_FR_b, V_thresh_b, V_reset_FR_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, rate_window_b, membrane_noise_b)        # run full AdExp analysis    r_post_CTR_AdExp, E_tot_CTR_AdExp, CV_V_m_CTR_AdExp, tuning_curve_CTR_AdExp, OSI_CTR_AdExp, OSI_per_energy_CTR_AdExp, CV_ISI_tuning_curve_CTR_AdExp, CV_ISI_tuning_curve_per_energy_CTR_AdExp, MI_tuning_curve_CTR_AdExp, MI_tuning_curve_per_energy_CTR_AdExp, MICE_tuning_curve_CTR_AdExp, MICE_tuning_curve_per_energy_CTR_AdExp, CV_ISI_CTR_AdExp, CV_ISI_per_energy_CTR_AdExp, MI_CTR_AdExp, MI_per_energy_CTR_AdExp, TE_CTR_AdExp, TE_per_energy_CTR_AdExp, MICE_CTR_AdExp, MICE_per_energy_CTR_AdExp, TECE_CTR_AdExp, TECE_per_energy_CTR_AdExp, E_vec_CTR_AdExp = af.complete_analysis(spike_times_post_CTR_AdExp, V_m_CTR_AdExp, T, R_m_CTR, C_m, E_L_CTR, I_syn_e_CTR_AdExp, V_thresh, spike_times_e, w_e_CTR, N_e_noise)    r_post_FR_AdExp, E_tot_FR_AdExp, CV_V_m_FR_AdExp, tuning_curve_FR_AdExp, OSI_FR_AdExp, OSI_per_energy_FR_AdExp, CV_ISI_tuning_curve_FR_AdExp, CV_ISI_tuning_curve_per_energy_FR_AdExp, MI_tuning_curve_FR_AdExp, MI_tuning_curve_per_energy_FR_AdExp, MICE_tuning_curve_FR_AdExp, MICE_tuning_curve_per_energy_FR_AdExp, CV_ISI_FR_AdExp, CV_ISI_per_energy_FR_AdExp, MI_FR_AdExp, MI_per_energy_FR_AdExp, TE_FR_AdExp, TE_per_energy_FR_AdExp, MICE_FR_AdExp, MICE_per_energy_FR_AdExp, TECE_FR_AdExp, TECE_per_energy_FR_AdExp, E_vec_FR_AdExp = af.complete_analysis(spike_times_post_FR_AdExp, V_m_FR_AdExp, T, R_m_FR, C_m, E_L_FR, I_syn_e_FR_AdExp, V_thresh, spike_times_e, w_e_FR, N_e_noise)    # save CTR results in AdExp dictionary     results_CTR_AdExp = save_results_dictionary(V_m_CTR_AdExp, I_syn_e_CTR_AdExp, I_syn_i_CTR_AdExp, spike_times_post_CTR_AdExp, r_post_CTR_AdExp, E_tot_CTR_AdExp, CV_V_m_CTR_AdExp, tuning_curve_CTR_AdExp, OSI_CTR_AdExp, OSI_per_energy_CTR_AdExp, CV_ISI_tuning_curve_CTR_AdExp, CV_ISI_tuning_curve_per_energy_CTR_AdExp, MI_tuning_curve_CTR_AdExp, MI_tuning_curve_per_energy_CTR_AdExp, MICE_tuning_curve_CTR_AdExp, MICE_tuning_curve_per_energy_CTR_AdExp, CV_ISI_CTR_AdExp, CV_ISI_per_energy_CTR_AdExp, MI_CTR_AdExp, MI_per_energy_CTR_AdExp, TE_CTR_AdExp, TE_per_energy_CTR_AdExp, MICE_CTR_AdExp, MICE_per_energy_CTR_AdExp, TECE_CTR_AdExp, TECE_per_energy_CTR_AdExp)    # save FR results in AdExp dictionary     results_FR_AdExp = save_results_dictionary(V_m_FR_AdExp, I_syn_e_FR_AdExp, I_syn_i_FR_AdExp, spike_times_post_FR_AdExp, r_post_FR_AdExp, E_tot_FR_AdExp, CV_V_m_FR_AdExp, tuning_curve_FR_AdExp, OSI_FR_AdExp, OSI_per_energy_FR_AdExp, CV_ISI_tuning_curve_FR_AdExp, CV_ISI_tuning_curve_per_energy_FR_AdExp, MI_tuning_curve_FR_AdExp, MI_tuning_curve_per_energy_FR_AdExp, MICE_tuning_curve_FR_AdExp, MICE_tuning_curve_per_energy_FR_AdExp, CV_ISI_FR_AdExp, CV_ISI_per_energy_FR_AdExp, MI_FR_AdExp, MI_per_energy_FR_AdExp, TE_FR_AdExp, TE_per_energy_FR_AdExp, MICE_FR_AdExp, MICE_per_energy_FR_AdExp, TECE_FR_AdExp, TECE_per_energy_FR_AdExp)    return results_CTR_LIF, results_FR_LIF, results_CTR_LIFexp, results_FR_LIFexp, results_CTR_LIFad, results_FR_LIFad, results_CTR_AdExp, results_FR_AdExp def multiple_CTR_FR_ad_or_exp_runs(number_single_runs, membrane_noise=0.0, synaptic_scaling_mode='multiplicative', savename=None):    # run a multiple CTR & FR simulations        # input    # number_single_runs is the number of single runs to perform    # membrane_noise is the standard deviation of the membrane noise in mV/ms    # synaptic_scaling_mode decides if synaptic weight distribution is scaled multiplicatively or non-multiplicatively    # savename is the name to save the grid as .pkl file    # output     # results_CTR_LIF, results_FR_LIF, results_CTR_LIFexp, results_FR_LIFexp, results_CTR_LIFad, results_FR_LIFad, results_CTR_AdExp, results_FR_AdExp are the results dictionaries    # initialize dictionaries to save results    results_single_runs_CTR_LIF, results_single_runs_FR_LIF, results_single_runs_CTR_LIFexp, results_single_runs_FR_LIFexp, results_single_runs_CTR_LIFad, results_single_runs_FR_LIFad, results_single_runs_CTR_AdExp, results_single_runs_FR_AdExp = empty_results_dictionary(), empty_results_dictionary(), empty_results_dictionary(), empty_results_dictionary(), empty_results_dictionary(), empty_results_dictionary(), empty_results_dictionary(), empty_results_dictionary()        for _ in range(0, number_single_runs):                 # simulate single run        results_CTR_LIF, results_FR_LIF, results_CTR_LIFexp, results_FR_LIFexp, results_CTR_LIFad, results_FR_LIFad, results_CTR_AdExp, results_FR_AdExp = single_CTR_FR_ad_or_exp_run(membrane_noise=membrane_noise, synaptic_scaling_mode=synaptic_scaling_mode)        for key, value in results_CTR_LIF.items():            results_single_runs_CTR_LIF[key].append(value)                for key, value in results_FR_LIF.items():            results_single_runs_FR_LIF[key].append(value)        for key, value in results_CTR_LIFexp.items():            results_single_runs_CTR_LIFexp[key].append(value)                for key, value in results_FR_LIFexp.items():            results_single_runs_FR_LIFexp[key].append(value)        for key, value in results_CTR_LIFad.items():            results_single_runs_CTR_LIFad[key].append(value)                for key, value in results_FR_LIFad.items():            results_single_runs_FR_LIFad[key].append(value)                for key, value in results_CTR_AdExp.items():            results_single_runs_CTR_AdExp[key].append(value)                for key, value in results_FR_AdExp.items():            results_single_runs_FR_AdExp[key].append(value)        # save results if savename is provided    if savename is not None:                with open(f'../Data/ad_or_exp/{savename}_results_single_runs_CTR_LIF.pkl', 'wb') as f:            pickle.dump(results_single_runs_CTR_LIF, f)        with open(f'../Data/ad_or_exp/{savename}_results_single_runs_FR_LIF.pkl', 'wb') as f:            pickle.dump(results_single_runs_FR_LIF, f)        with open(f'../Data/ad_or_exp/{savename}_results_single_runs_CTR_LIFexp.pkl', 'wb') as f:            pickle.dump(results_single_runs_CTR_LIFexp, f)        with open(f'../Data/ad_or_exp/{savename}_results_single_runs_FR_LIFexp.pkl', 'wb') as f:            pickle.dump(results_single_runs_FR_LIFexp, f)        with open(f'../Data/ad_or_exp/{savename}_results_single_runs_CTR_LIFad.pkl', 'wb') as f:            pickle.dump(results_single_runs_CTR_LIFad, f)        with open(f'../Data/ad_or_exp/{savename}_results_single_runs_FR_LIFad.pkl', 'wb') as f:            pickle.dump(results_single_runs_FR_LIFad, f)        with open(f'../Data/ad_or_exp/{savename}_results_single_runs_CTR_AdExp.pkl', 'wb') as f:            pickle.dump(results_single_runs_CTR_AdExp, f)        with open(f'../Data/ad_or_exp/{savename}_results_single_runs_FR_AdExp.pkl', 'wb') as f:            pickle.dump(results_single_runs_FR_AdExp, f)        return results_single_runs_CTR_LIF, results_single_runs_FR_LIF, results_single_runs_CTR_LIFexp, results_single_runs_FR_LIFexp, results_single_runs_CTR_LIFad, results_single_runs_FR_LIFad, results_single_runs_CTR_AdExp, results_single_runs_FR_AdExp########################################### different membrane noise level runs ####################################################################################def single_CTR_FR_membrane_noise_run(model_mode, membrane_noise_vec, synaptic_scaling_mode='multiplicative'):    # run a single single simulation        # input    # model_mode is a list of strings or string & decides which model is used for simulation    # membrane_noise_vec is an array of membrane noise values    # synaptic_scaling_mode decides if synaptic weight distribution is scaled multiplicatively or non-multiplicatively    # output     # results_LIF, results_AdExp are the results dictionaries    # initialize dictionaries to save results    results_membrane_noise_CTR_LIF, results_membrane_noise_FR_LIF, results_membrane_noise_CTR_AdExp, results_membrane_noise_FR_AdExp = empty_results_dictionary(), empty_results_dictionary(), empty_results_dictionary(), empty_results_dictionary()        # load parameter values    # define synaptic input    if synaptic_scaling_mode == 'multiplicative':         N_syn, N_e, N_e_signal_ratio, N_i, rate_background_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, mu_weight_e, sigma_weight_e, mu_weight_i, sigma_weight_i = sif.synaptic_parameters(synaptic_scaling_mode=synaptic_scaling_mode)                # orientation variation input        w_e_0, w_i_0, spike_times_e, spike_times_i, r_e, r_i, t_stim, T, N_e_signal, N_e_noise = sif.orientation_variation_input(N_e, N_i, N_e_signal_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, rate_background_ratio, mu_weight_e, sigma_weight_e, mu_weight_i, sigma_weight_i)        w_e_0_CTR, w_i_0_CTR, w_e_0_FR, w_i_0_FR = w_e_0, w_i_0, w_e_0, w_i_0            if synaptic_scaling_mode == 'non-multiplicative':         N_syn, N_e, N_e_signal_ratio, N_i, rate_background_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, mu_weight_e_CTR, sigma_weight_e_CTR, mu_weight_i_CTR, sigma_weight_i_CTR, mu_weight_e_FR, sigma_weight_e_FR, mu_weight_i_FR, sigma_weight_i_FR = sif.synaptic_parameters(synaptic_scaling_mode=synaptic_scaling_mode)        w_e_0_CTR, w_i_0_CTR, spike_times_e, spike_times_i, r_e, r_i, t_stim, T, N_e_signal, N_e_noise = sif.orientation_variation_input(N_e, N_i, N_e_signal_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, rate_background_ratio, mu_weight_e_CTR, sigma_weight_e_CTR, mu_weight_i_CTR, sigma_weight_i_CTR)        w_e_0_FR, w_i_0_FR, _, _, _, _, _, _, _, _ = sif.orientation_variation_input(N_e, N_i, N_e_signal_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, rate_background_ratio, mu_weight_e_FR, sigma_weight_e_FR, mu_weight_i_FR, sigma_weight_i_FR)        # load CTR parameter values    C_m, E_L_CTR, R_m_CTR, g_L_CTR, V_thresh, V_reset_CTR, rate_window, E_e, E_i, tau_e, tau_i, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise = sim_parameters(parameter_mode='CTR', membrane_noise=0.0)    # load FR parameter values    C_m, E_L_FR, R_m_FR, g_L_FR, V_thresh, V_reset_FR, rate_window, E_e, E_i, tau_e, tau_i, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise = sim_parameters(parameter_mode='FR', membrane_noise=0.0)    # scale CTR synaptic input    w_scale_CTR = 100    w_e_CTR = w_e_0_CTR * 5 * w_scale_CTR * 4 # low E/I balance: 4/1    w_i_CTR = w_i_0_CTR * 5 * w_scale_CTR * 1 # low E/I balance: 4/1    # scale FR synaptic input    w_scale_FR = w_scale_CTR*0.7 # 0.65    w_e_FR = w_e_0_FR * 5 * w_scale_FR * 4 # low E/I balance: 4/1    w_i_FR = w_i_0_FR * 5 * w_scale_FR * 1 # low E/I balance: 4/1        # loop over membrane noise    for membrane_noise in membrane_noise_vec:         membrane_noise = membrane_noise        # initialize dictionaries to save results        results_CTR_LIF = {}        results_FR_LIF = {}        results_CTR_AdExp = {}        results_FR_AdExp = {}        # translate CTR to Brian-readable values        T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_CTR_b, w_i_CTR_b, tau_e_b, tau_i_b, C_m_b, g_L_CTR_b, E_L_CTR_b, V_thresh_b, V_reset_CTR_b, rate_window_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, membrane_noise_b = parameters_brian(T, N_e, N_i, spike_times_e, spike_times_i, E_e, E_i, w_e_CTR, w_i_CTR, tau_e, tau_i, C_m, g_L_CTR, E_L_CTR, V_thresh, V_reset_CTR, rate_window, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise)                # translate FR to Brian-readable values        T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_FR_b, w_i_FR_b, tau_e_b, tau_i_b, C_m_b, g_L_FR_b, E_L_FR_b, V_thresh_b, V_reset_FR_b, rate_window_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, membrane_noise_b = parameters_brian(T, N_e, N_i, spike_times_e, spike_times_i, E_e, E_i, w_e_FR, w_i_FR, tau_e, tau_i, C_m, g_L_FR, E_L_FR, V_thresh, V_reset_FR, rate_window, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise)                # simulate LIF if given            if 'LIF' in model_mode:                        # scale synaptic input            w_e_CTR_LIF_b = w_e_CTR_b            w_i_CTR_LIF_b = w_i_CTR_b            w_e_FR_LIF_b = w_e_FR_b            w_i_FR_LIF_b = w_i_FR_b                # simulate LIF            time_CTR_LIF, V_m_CTR_LIF, spike_times_post_CTR_LIF, rate_estimate_post_CTR_LIF, I_syn_e_CTR_LIF, I_syn_i_CTR_LIF, g_e_CTR_LIF, g_i_CTR_LIF = LIF(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_CTR_LIF_b, w_i_CTR_LIF_b, tau_e_b, tau_i_b, C_m_b, g_L_CTR_b, E_L_CTR_b, V_thresh_b, V_reset_CTR_b, rate_window_b, membrane_noise_b)            time_FR_LIF, V_m_FR_LIF, spike_times_post_FR_LIF, rate_estimate_post_FR_LIF, I_syn_e_FR_LIF, I_syn_i_FR_LIF, g_e_FR_LIF, g_i_FR_LIF = LIF(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_FR_LIF_b, w_i_FR_LIF_b, tau_e_b, tau_i_b, C_m_b, g_L_FR_b, E_L_FR_b, V_thresh_b, V_reset_FR_b, rate_window_b, membrane_noise_b)                # run full LIF analysis            r_post_CTR_LIF, E_tot_CTR_LIF, CV_V_m_CTR_LIF, tuning_curve_CTR_LIF, OSI_CTR_LIF, OSI_per_energy_CTR_LIF, CV_ISI_tuning_curve_CTR_LIF, CV_ISI_tuning_curve_per_energy_CTR_LIF, MI_tuning_curve_CTR_LIF, MI_tuning_curve_per_energy_CTR_LIF, MICE_tuning_curve_CTR_LIF, MICE_tuning_curve_per_energy_CTR_LIF, CV_ISI_CTR_LIF, CV_ISI_per_energy_CTR_LIF, MI_CTR_LIF, MI_per_energy_CTR_LIF, TE_CTR_LIF, TE_per_energy_CTR_LIF, MICE_CTR_LIF, MICE_per_energy_CTR_LIF, TECE_CTR_LIF, TECE_per_energy_CTR_LIF, E_vec_CTR_LIF = af.complete_analysis(spike_times_post_CTR_LIF, V_m_CTR_LIF, T, R_m_CTR, C_m, E_L_CTR, I_syn_e_CTR_LIF, V_thresh, spike_times_e, w_e_CTR, N_e_noise)            r_post_FR_LIF, E_tot_FR_LIF, CV_V_m_FR_LIF, tuning_curve_FR_LIF, OSI_FR_LIF, OSI_per_energy_FR_LIF, CV_ISI_tuning_curve_FR_LIF, CV_ISI_tuning_curve_per_energy_FR_LIF, MI_tuning_curve_FR_LIF, MI_tuning_curve_per_energy_FR_LIF, MICE_tuning_curve_FR_LIF, MICE_tuning_curve_per_energy_FR_LIF, CV_ISI_FR_LIF, CV_ISI_per_energy_FR_LIF, MI_FR_LIF, MI_per_energy_FR_LIF, TE_FR_LIF, TE_per_energy_FR_LIF, MICE_FR_LIF, MICE_per_energy_FR_LIF, TECE_FR_LIF, TECE_per_energy_FR_LIF, E_vec_FR_LIF = af.complete_analysis(spike_times_post_FR_LIF, V_m_FR_LIF, T, R_m_FR, C_m, E_L_FR, I_syn_e_FR_LIF, V_thresh, spike_times_e, w_e_FR, N_e_noise)            # save CTR results in LIF dictionary             results_CTR_LIF = save_results_dictionary(V_m_CTR_LIF, I_syn_e_CTR_LIF, I_syn_i_CTR_LIF, spike_times_post_CTR_LIF, r_post_CTR_LIF, E_tot_CTR_LIF, CV_V_m_CTR_LIF, tuning_curve_CTR_LIF, OSI_CTR_LIF, OSI_per_energy_CTR_LIF, CV_ISI_tuning_curve_CTR_LIF, CV_ISI_tuning_curve_per_energy_CTR_LIF, MI_tuning_curve_CTR_LIF, MI_tuning_curve_per_energy_CTR_LIF, MICE_tuning_curve_CTR_LIF, MICE_tuning_curve_per_energy_CTR_LIF, CV_ISI_CTR_LIF, CV_ISI_per_energy_CTR_LIF, MI_CTR_LIF, MI_per_energy_CTR_LIF, TE_CTR_LIF, TE_per_energy_CTR_LIF, MICE_CTR_LIF, MICE_per_energy_CTR_LIF, TECE_CTR_LIF, TECE_per_energy_CTR_LIF)                # save FR results in LIF dictionary              results_FR_LIF = save_results_dictionary(V_m_FR_LIF, I_syn_e_FR_LIF, I_syn_i_FR_LIF, spike_times_post_FR_LIF, r_post_FR_LIF, E_tot_FR_LIF, CV_V_m_FR_LIF, tuning_curve_FR_LIF, OSI_FR_LIF, OSI_per_energy_FR_LIF, CV_ISI_tuning_curve_FR_LIF, CV_ISI_tuning_curve_per_energy_FR_LIF, MI_tuning_curve_FR_LIF, MI_tuning_curve_per_energy_FR_LIF, MICE_tuning_curve_FR_LIF, MICE_tuning_curve_per_energy_FR_LIF, CV_ISI_FR_LIF, CV_ISI_per_energy_FR_LIF, MI_FR_LIF, MI_per_energy_FR_LIF, TE_FR_LIF, TE_per_energy_FR_LIF, MICE_FR_LIF, MICE_per_energy_FR_LIF, TECE_FR_LIF, TECE_per_energy_FR_LIF)                        # append values to results dictionary            for key, value in results_CTR_LIF.items():                results_membrane_noise_CTR_LIF[key].append(value)                        for key, value in results_FR_LIF.items():                results_membrane_noise_FR_LIF[key].append(value)                # simulate AdExp if given          if 'AdExp' in model_mode:                               # scale synaptic input            weight_factor_LIF_to_AdExp = 1.0 #1.5            w_e_CTR_AdExp_b = w_e_CTR_b * weight_factor_LIF_to_AdExp            w_i_CTR_AdExp_b = w_i_CTR_b * weight_factor_LIF_to_AdExp            w_e_FR_AdExp_b = w_e_FR_b * weight_factor_LIF_to_AdExp            w_i_FR_AdExp_b = w_i_FR_b * weight_factor_LIF_to_AdExp                        # simulate AdExp            time_CTR_AdExp, V_m_CTR_AdExp, spike_times_post_CTR_AdExp, rate_estimate_post_CTR_AdExp, I_syn_e_CTR_AdExp, I_syn_i_CTR_AdExp, g_e_CTR_AdExp, g_i_CTR_AdExp = AdExp(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_CTR_AdExp_b, w_i_CTR_AdExp_b, tau_e_b, tau_i_b, C_m_b, g_L_CTR_b, E_L_CTR_b, V_thresh_b, V_reset_CTR_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, rate_window_b, membrane_noise_b)            time_FR_AdExp, V_m_FR_AdExp, spike_times_post_FR_AdExp, rate_estimate_post_FR_AdExp, I_syn_e_FR_AdExp, I_syn_i_FR_AdExp, g_e_FR_AdExp, g_i_FR_AdExp = AdExp(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_FR_AdExp_b, w_i_FR_AdExp_b, tau_e_b, tau_i_b, C_m_b, g_L_FR_b, E_L_FR_b, V_thresh_b, V_reset_FR_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, rate_window_b, membrane_noise_b)                        # run full AdExp analysis            r_post_CTR_AdExp, E_tot_CTR_AdExp, CV_V_m_CTR_AdExp, tuning_curve_CTR_AdExp, OSI_CTR_AdExp, OSI_per_energy_CTR_AdExp, CV_ISI_tuning_curve_CTR_AdExp, CV_ISI_tuning_curve_per_energy_CTR_AdExp, MI_tuning_curve_CTR_AdExp, MI_tuning_curve_per_energy_CTR_AdExp, MICE_tuning_curve_CTR_AdExp, MICE_tuning_curve_per_energy_CTR_AdExp, CV_ISI_CTR_AdExp, CV_ISI_per_energy_CTR_AdExp, MI_CTR_AdExp, MI_per_energy_CTR_AdExp, TE_CTR_AdExp, TE_per_energy_CTR_AdExp, MICE_CTR_AdExp, MICE_per_energy_CTR_AdExp, TECE_CTR_AdExp, TECE_per_energy_CTR_AdExp, E_vec_CTR_AdExp = af.complete_analysis(spike_times_post_CTR_AdExp, V_m_CTR_AdExp, T, R_m_CTR, C_m, E_L_CTR, I_syn_e_CTR_AdExp, V_thresh, spike_times_e, w_e_CTR, N_e_noise)            r_post_FR_AdExp, E_tot_FR_AdExp, CV_V_m_FR_AdExp, tuning_curve_FR_AdExp, OSI_FR_AdExp, OSI_per_energy_FR_AdExp, CV_ISI_tuning_curve_FR_AdExp, CV_ISI_tuning_curve_per_energy_FR_AdExp, MI_tuning_curve_FR_AdExp, MI_tuning_curve_per_energy_FR_AdExp, MICE_tuning_curve_FR_AdExp, MICE_tuning_curve_per_energy_FR_AdExp, CV_ISI_FR_AdExp, CV_ISI_per_energy_FR_AdExp, MI_FR_AdExp, MI_per_energy_FR_AdExp, TE_FR_AdExp, TE_per_energy_FR_AdExp, MICE_FR_AdExp, MICE_per_energy_FR_AdExp, TECE_FR_AdExp, TECE_per_energy_FR_AdExp, E_vec_FR_AdExp = af.complete_analysis(spike_times_post_FR_AdExp, V_m_FR_AdExp, T, R_m_FR, C_m, E_L_FR, I_syn_e_FR_AdExp, V_thresh, spike_times_e, w_e_FR, N_e_noise)            # save CTR results in AdExp dictionary             results_CTR_AdExp = save_results_dictionary(V_m_CTR_AdExp, I_syn_e_CTR_AdExp, I_syn_i_CTR_AdExp, spike_times_post_CTR_AdExp, r_post_CTR_AdExp, E_tot_CTR_AdExp, CV_V_m_CTR_AdExp, tuning_curve_CTR_AdExp, OSI_CTR_AdExp, OSI_per_energy_CTR_AdExp, CV_ISI_tuning_curve_CTR_AdExp, CV_ISI_tuning_curve_per_energy_CTR_AdExp, MI_tuning_curve_CTR_AdExp, MI_tuning_curve_per_energy_CTR_AdExp, MICE_tuning_curve_CTR_AdExp, MICE_tuning_curve_per_energy_CTR_AdExp, CV_ISI_CTR_AdExp, CV_ISI_per_energy_CTR_AdExp, MI_CTR_AdExp, MI_per_energy_CTR_AdExp, TE_CTR_AdExp, TE_per_energy_CTR_AdExp, MICE_CTR_AdExp, MICE_per_energy_CTR_AdExp, TECE_CTR_AdExp, TECE_per_energy_CTR_AdExp)                # save FR results in AdExp dictionary             results_FR_AdExp = save_results_dictionary(V_m_FR_AdExp, I_syn_e_FR_AdExp, I_syn_i_FR_AdExp, spike_times_post_FR_AdExp, r_post_FR_AdExp, E_tot_FR_AdExp, CV_V_m_FR_AdExp, tuning_curve_FR_AdExp, OSI_FR_AdExp, OSI_per_energy_FR_AdExp, CV_ISI_tuning_curve_FR_AdExp, CV_ISI_tuning_curve_per_energy_FR_AdExp, MI_tuning_curve_FR_AdExp, MI_tuning_curve_per_energy_FR_AdExp, MICE_tuning_curve_FR_AdExp, MICE_tuning_curve_per_energy_FR_AdExp, CV_ISI_FR_AdExp, CV_ISI_per_energy_FR_AdExp, MI_FR_AdExp, MI_per_energy_FR_AdExp, TE_FR_AdExp, TE_per_energy_FR_AdExp, MICE_FR_AdExp, MICE_per_energy_FR_AdExp, TECE_FR_AdExp, TECE_per_energy_FR_AdExp)            # append values to results dictionary            for key, value in results_CTR_AdExp.items():                results_membrane_noise_CTR_AdExp[key].append(value)                        for key, value in results_FR_AdExp.items():                results_membrane_noise_FR_AdExp[key].append(value)                    return results_membrane_noise_CTR_LIF, results_membrane_noise_FR_LIF, results_membrane_noise_CTR_AdExp, results_membrane_noise_FR_AdExpdef multiple_CTR_FR_membrane_noise_runs(number_single_runs, model_mode, membrane_noise_vec, synaptic_scaling_mode='multiplicative', savename=None):    # run a multiple single simulations        # input    # number_single_runs is the number of single runs to perform    # model_mode is a list of strings or string & decides which model is used for simulation    # membrane_noise_vec is an array of membrane noise values    # synaptic_scaling_mode decides if synaptic weight distribution is scaled multiplicatively or non-multiplicatively    # savename is the name to save the grid as .pkl file    # output     # results_LIF, results_AdExp are the results dictionaries    # initialize dictionaries to save results    results_single_runs_CTR_LIF, results_single_runs_FR_LIF, results_single_runs_CTR_AdExp, results_single_runs_FR_AdExp = empty_results_dictionary(), empty_results_dictionary(), empty_results_dictionary(), empty_results_dictionary()        for _ in range(0, number_single_runs):                 # simulate single run        results_CTR_LIF, results_FR_LIF, results_CTR_AdExp, results_FR_AdExp = single_CTR_FR_membrane_noise_run(model_mode=model_mode, membrane_noise_vec=membrane_noise_vec, synaptic_scaling_mode=synaptic_scaling_mode)        for key, value in results_CTR_LIF.items():            results_single_runs_CTR_LIF[key].append(value)                for key, value in results_FR_LIF.items():            results_single_runs_FR_LIF[key].append(value)                for key, value in results_CTR_AdExp.items():            results_single_runs_CTR_AdExp[key].append(value)                for key, value in results_FR_AdExp.items():            results_single_runs_FR_AdExp[key].append(value)        results_single_runs_CTR_LIF['membrane_noise_vec']=membrane_noise_vec    results_single_runs_FR_LIF['membrane_noise_vec']=membrane_noise_vec    results_single_runs_CTR_AdExp['membrane_noise_vec']=membrane_noise_vec    results_single_runs_FR_AdExp['membrane_noise_vec']=membrane_noise_vec        results_single_runs_CTR_FR_LIF = [results_single_runs_CTR_LIF, results_single_runs_FR_LIF]    results_single_runs_CTR_FR_AdExp = [results_single_runs_CTR_AdExp, results_single_runs_FR_AdExp]        # save results if savename is provided    if savename is not None:        if 'LIF' in model_mode:            with open(f'{savename}_results_single_runs_membrane_noise_CTR_FR_LIF.pkl', 'wb') as f:                pickle.dump(results_single_runs_CTR_FR_LIF, f)        if 'AdExp' in model_mode:            with open(f'{savename}_results_single_runs_membrane_noise_CTR_FR_AdExp.pkl', 'wb') as f:                pickle.dump(results_single_runs_CTR_FR_AdExp, f)        return results_single_runs_CTR_FR_LIF, results_single_runs_CTR_FR_AdExp########################################### adaptation current quantification runs ####################################################################################def AdExp_adaptation(T, N_e, N_i, spike_times_e, spike_times_i, E_e, E_i, w_e, w_i, tau_e, tau_i, C_m, g_L, E_L, V_thresh, V_reset, Delta_T, tau_w, a, b, rate_window, membrane_noise):    # simulation AdExp model        # input    # T is the duration of the simulation in ms    # N_e is the number of excitatory synaptic inputs    # N_i is the number of inhibitory synaptic inputs    # spike_times_e is an array of excitatory input spike trains    # spike_times_i is an array of inhibitory input spike trains    # E_e is the reversal potential for excitatory inputs in mV    # E_i is the reversal potential for inhibitory inputs in mV    # w_e are the weights of exc. input    # w_i are the weights of inh. input    # tau_e is the postsynaptic potential (PSP) time constant for exc. input in ms    # tau_i is the postsynaptic potential (PSP) time constant for inh. input in ms    # C_m is the membrane capacitance in pF    # g_L is the leak conductance in nS    # E_L is the resting potential (leak reversal potential) / mV    # V_thresh is the spike generation threshold in mV    # V_reset is the reset potential in mV    # Delta_T is the slope factor in mV    # tau_w is the adaptation time constant in ms    # a is the subthreshold adaptation in nS    # b is the spike-triggered adaptation in pA    # rate_window is the integration time for the online firing-rate estimation in ms    # membrane_noise is the standard deviation of the membrane noise in mV/ms    # output     # time is an array of length n of the time    # V_m is an array of length n of the membrane voltage    # spike_times_post is a list of postsynaptic spike times    # rate_estimate_post  is an array of length n of instantaneous firing rates    # I_syn_e is an array of length n of excitatory synaptic current    # I_syn_i is an array of length n of inhibitory synaptic current    # g_e is an array of length n of excitatory conductances    # g_i is an array of length n of inhibitory conductances    # w_ad is the adaptation current in nA    #defaultclock.dt = dt*ms    N = 1  # number of postsynaptic neurons    # define V_T & spiking threshold    V_T = V_thresh - 2.5 * Delta_T    V_thresh_spike_detection = V_thresh + 2.5 * Delta_T        if membrane_noise == 0.0:         eqs = '''        dV_m/dt = (g_L*(E_L - V_m) + g_L*Delta_T*exp((V_m - V_T)/Delta_T) - w_ad + I_syn_e + I_syn_i) / C_m : volt        dw_ad/dt = (a*(V_m - E_L) - w_ad) / tau_w : amp        I_syn_e = g_e*(E_e - V_m) : amp        I_syn_i = g_i*(E_i - V_m) : amp        dg_e/dt = -g_e / tau_e : siemens        dg_i/dt = -g_i / tau_i : siemens        '''                neuron = NeuronGroup(N, model=eqs, threshold='V_m > V_thresh_spike_detection', reset='V_m = V_reset; w_ad += b', method='exponential_euler')        neuron.V_m = V_reset            if membrane_noise > 0.0:         eqs = '''        dV_m/dt = (g_L*(E_L - V_m) + g_L*Delta_T*exp((V_m - V_T)/Delta_T) - w_ad + I_syn_e + I_syn_i) / C_m + membrane_noise*xi*sqrt(dt)  : volt        dw_ad/dt = (a*(V_m - E_L) - w_ad) / tau_w : amp        I_syn_e = g_e*(E_e - V_m) : amp        I_syn_i = g_i*(E_i - V_m) : amp        dg_e/dt = -g_e / tau_e : siemens        dg_i/dt = -g_i / tau_i : siemens        '''        # for temporally correlated noise multiply noise term with * sqrt(2/tau_noise) with tau_noise=5–50 ms                neuron = NeuronGroup(N, model=eqs, threshold='V_m > V_thresh_spike_detection', reset='V_m = V_reset; w_ad += b', method='euler')        neuron.V_m = V_reset                # convert spike_times_e and spike_times_i to SpikeGeneratorGroup format    indices_e, times_e = zip(*[(i, spike) for i, spikes in spike_times_e.items() for spike in spikes])    indices_i, times_i = zip(*[(i, spike) for i, spikes in spike_times_i.items() for spike in spikes])    G_e = SpikeGeneratorGroup(N_e, indices_e, times_e)    G_i = SpikeGeneratorGroup(N_i, indices_i, times_i)    exc_synapses = Synapses(G_e, neuron, 'w: siemens', on_pre='g_e += w')    exc_synapses.connect()    for i, weight in enumerate(w_e):        exc_synapses.w[i] = weight    inh_synapses = Synapses(G_i, neuron, 'w: siemens', on_pre='g_i += w')    inh_synapses.connect()    for i, weight in enumerate(w_i):        inh_synapses.w[i] = weight    spikes = SpikeMonitor(neuron)    rate_monitor = PopulationRateMonitor(neuron)    post_states = StateMonitor(neuron, ('V_m', 'I_syn_e', 'I_syn_i', 'g_e', 'g_i', 'w_ad'), record=True)        run(T, report='text')    time = post_states.t / second    V_m = post_states.V_m[0] / mV    spike_times_post = spikes.t / ms    rate_estimate_post = rate_monitor.smooth_rate(window='flat', width=rate_window) / Hz # alternative window mode 'gaussian'    I_syn_e = post_states.I_syn_e[0] / nA    I_syn_i = post_states.I_syn_i[0] / nA    g_e = post_states.g_e[0] / nS    g_i = post_states.g_i[0] / nS    w_ad = post_states.w_ad[0] / nA    return time, V_m, spike_times_post, rate_estimate_post, I_syn_e, I_syn_i, g_e, g_i, w_addef single_adaptation_run(w_e_scale_list, tau_w_ad):    # quantify strength of adaptation current for a given tau_w_ad        # input    # w_e_scale_list is a list of synaptic weights    # tau_w_ad is the adaptation time constant in ms    # output    # r_post_list is a list of the firing frequencies in Hz    # w_ad_list is a list of the adaptation currents in nA    # I_syn_list is a list of the synaptic currents    # tau_w_ad is the used adaptation time constant    # define synaptic input    N_syn, N_e, N_e_signal_ratio, N_i, rate_background_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, mu_weight_e, sigma_weight_e, mu_weight_i, sigma_weight_i = sif.synaptic_parameters(synaptic_scaling_mode='multiplicative')        # orientation variation input    w_e_0, w_i_0, spike_times_e, spike_times_i, r_e, r_i, t_stim, T, N_e_signal, N_e_noise = sif.orientation_variation_input(N_e, N_i, N_e_signal_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, rate_background_ratio, mu_weight_e, sigma_weight_e, mu_weight_i, sigma_weight_i)        # CTR run    C_m, E_L, R_m, g_L, V_thresh, V_reset, rate_window, E_e, E_i, tau_e, tau_i, Delta_T_ad, _, a_ad, b_ad, sigma_membrane_noise = sim_parameters(parameter_mode='CTR', membrane_noise=0.0)        # prepare output lists    r_post_list = []    w_ad_list = []    I_syn_e_list = []    # loop over scaling values    for scale in w_e_scale_list:        # scale synaptic weights        w_e = w_e_0 * 5 * scale * 4        w_i = w_i_0 * 5 * scale * 1        # translate them to Brian-readable values        T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_b, w_i_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_b, V_thresh_b, V_reset_b, rate_window_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, sigma_membrane_noise_b = parameters_brian(T, N_e, N_i, spike_times_e, spike_times_i, E_e, E_i, w_e, w_i, tau_e, tau_i, C_m, g_L, E_L, V_thresh, V_reset, rate_window, Delta_T_ad, tau_w_ad, a_ad, b_ad, sigma_membrane_noise)        # simulate AdExp        time, V_m, spike_times_post, rate_estimate_post, I_syn_e, I_syn_i, g_e, g_i, w_ad = AdExp_adaptation(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_b, w_i_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_b, V_thresh_b, V_reset_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, rate_window_b, sigma_membrane_noise_b)                # run full analysis        r_post, E_tot, CV_V_m, tuning_curve, OSI, OSI_per_energy, CV_ISI_tuning_curve, CV_ISI_tuning_curve_per_energy, MI_tuning_curve, MI_tuning_curve_per_energy, MICE_tuning_curve, MICE_tuning_curve_per_energy, CV_ISI, CV_ISI_per_energy, MI, MI_per_energy, TE, TE_per_energy, MICE, MICE_per_energy, TECE, TECE_per_energy, E_vec = af.complete_analysis(spike_times_post, V_m, T, R_m, C_m, E_L, I_syn_e, V_thresh, spike_times_e, w_e, N_e_noise)        # Store results        r_post_list.append(r_post)        w_ad_list.append(w_ad)        I_syn_e_list.append(I_syn_e)    return r_post_list, w_ad_list, I_syn_e_list, tau_w_addef multiple_adaptation_runs(w_e_scale_list, tau_w_ad_list, savename=None):    # quantify strength of adaptation current for several given tau_w_ads        # input    # w_e_scale_list is a list of synaptic weights    # tau_w_ad_list is a list of adaptation time constant in ms    # savename is the save name of the pickle file    # output    # results_adaptation is a list of result dictionaries        results_adaptation = []    # loop through tau_w_ads    for tau_w_ad in tau_w_ad_list:        r_post_list, w_ad_list, I_syn_e_list, _ = single_adaptation_run(w_e_scale_list, tau_w_ad)        result_adaptation = {            'tau_w_ad': tau_w_ad,            'w_e_scale_list': w_e_scale_list,            'r_post_list': r_post_list,            'w_ad_list': [np.mean(w_ad) for w_ad in w_ad_list],            'I_syn_e_list': [np.mean(I_syn) for I_syn in I_syn_e_list]}                results_adaptation.append(result_adaptation)        with open(f'../Data/adaptation_runs/{savename}.pkl', 'wb') as f:        pickle.dump(results_adaptation, f)    return results_adaptation########################################### energy contribution runs ####################################################################################def single_energy_contributors_run(w_scale_CTR, w_scale_FR, membrane_noise=0.0):    # run a single simulation to estimate r_post & I_syn_e for energy calculations        # input    # w_scale_CTR, w_scale_FR are synaptic scaling factors for CTR & FR    # membrane_noise is the standard deviation of the membrane noise in mV/ms        # output     # r_post_CTR, r_post_FR are postsynaptic firing rates    # I_syn_e_CTR, I_syn_e_FR are excitatory synaptic currents        # load parameter values    # define synaptic input    N_syn, N_e, N_e_signal_ratio, N_i, rate_background_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, mu_weight_e, sigma_weight_e, mu_weight_i, sigma_weight_i = sif.synaptic_parameters(synaptic_scaling_mode='multiplicative')        # orientation variation input    w_e_0, w_i_0, spike_times_e, spike_times_i, r_e, r_i, t_stim, T, N_e_signal, N_e_noise = sif.orientation_variation_input(N_e, N_i, N_e_signal_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, rate_background_ratio, mu_weight_e, sigma_weight_e, mu_weight_i, sigma_weight_i)    w_e_0_CTR, w_i_0_CTR, w_e_0_FR, w_i_0_FR = w_e_0, w_i_0, w_e_0, w_i_0            # load CTR parameter values    C_m, E_L_CTR, R_m_CTR, g_L_CTR, V_thresh, V_reset_CTR, rate_window, E_e, E_i, tau_e, tau_i, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise = sim_parameters(parameter_mode='CTR', membrane_noise=membrane_noise)    # load FR parameter values    C_m, E_L_FR, R_m_FR, g_L_FR, V_thresh, V_reset_FR, rate_window, E_e, E_i, tau_e, tau_i, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise = sim_parameters(parameter_mode='FR', membrane_noise=membrane_noise)    # scale CTR synaptic input    w_scale_CTR = w_scale_CTR    w_e_CTR = w_e_0_CTR * 5 * w_scale_CTR * 4 # low E/I balance: 4/1    w_i_CTR = w_i_0_CTR * 5 * w_scale_CTR * 1 # low E/I balance: 4/1    # scale FR synaptic input    w_scale_FR = w_scale_FR    w_e_FR = w_e_0_FR * 5 * w_scale_FR * 4 # low E/I balance: 4/1    w_i_FR = w_i_0_FR * 5 * w_scale_FR * 1 # low E/I balance: 4/1    # translate CTR to Brian-readable values    T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_CTR_b, w_i_CTR_b, tau_e_b, tau_i_b, C_m_b, g_L_CTR_b, E_L_CTR_b, V_thresh_b, V_reset_CTR_b, rate_window_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, membrane_noise_b = parameters_brian(T, N_e, N_i, spike_times_e, spike_times_i, E_e, E_i, w_e_CTR, w_i_CTR, tau_e, tau_i, C_m, g_L_CTR, E_L_CTR, V_thresh, V_reset_CTR, rate_window, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise)        # translate FR to Brian-readable values    T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_FR_b, w_i_FR_b, tau_e_b, tau_i_b, C_m_b, g_L_FR_b, E_L_FR_b, V_thresh_b, V_reset_FR_b, rate_window_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, membrane_noise_b = parameters_brian(T, N_e, N_i, spike_times_e, spike_times_i, E_e, E_i, w_e_FR, w_i_FR, tau_e, tau_i, C_m, g_L_FR, E_L_FR, V_thresh, V_reset_FR, rate_window, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise)        # simulate LIF          # scale synaptic input    w_e_CTR_LIF_b = w_e_CTR_b    w_i_CTR_LIF_b = w_i_CTR_b    w_e_FR_LIF_b = w_e_FR_b    w_i_FR_LIF_b = w_i_FR_b    # simulate LIF    time_CTR_LIF, V_m_CTR_LIF, spike_times_post_CTR_LIF, rate_estimate_post_CTR_LIF, I_syn_e_CTR_LIF, I_syn_i_CTR_LIF, g_e_CTR_LIF, g_i_CTR_LIF = LIF(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_CTR_LIF_b, w_i_CTR_LIF_b, tau_e_b, tau_i_b, C_m_b, g_L_CTR_b, E_L_CTR_b, V_thresh_b, V_reset_CTR_b, rate_window_b, membrane_noise_b)    time_FR_LIF, V_m_FR_LIF, spike_times_post_FR_LIF, rate_estimate_post_FR_LIF, I_syn_e_FR_LIF, I_syn_i_FR_LIF, g_e_FR_LIF, g_i_FR_LIF = LIF(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_FR_LIF_b, w_i_FR_LIF_b, tau_e_b, tau_i_b, C_m_b, g_L_FR_b, E_L_FR_b, V_thresh_b, V_reset_FR_b, rate_window_b, membrane_noise_b)    # run full LIF analysis    r_post_CTR_LIF = len(spike_times_post_CTR_LIF) / T * 1000     r_post_FR_LIF = len(spike_times_post_FR_LIF) / T * 1000            return r_post_CTR_LIF, r_post_FR_LIF, np.mean(I_syn_e_CTR_LIF), np.mean(I_syn_e_FR_LIF)def multiple_energy_contributors_run(w_scales_CTR, w_scales_FR, membrane_noise=0.0):    # run a single simulation to estimate r_post & I_syn_e for energy calculations        # input    # w_scales_CTR, w_scales_FR are lists of synaptic scaling factors for CTR & FR    # membrane_noise is the standard deviation of the membrane noise in mV/ms    # output     # r_post_CTR, r_post_FR are lists of postsynaptic firing rates    # I_syn_e_CTR, I_syn_e_FR are lists of excitatory synaptic currents        # load parameter values        # initialize lists    r_post_CTR = []    I_syn_e_CTR = []    r_post_FR = []    I_syn_e_FR = []        for w_scale_CTR, w_scale_FR in zip(w_scales_CTR, w_scales_FR):        r_post_CTR_LIF, r_post_FR_LIF, I_syn_e_CTR_LIF, I_syn_e_FR_LIF = single_energy_contributors_run(w_scale_CTR, w_scale_FR, membrane_noise=membrane_noise)        r_post_CTR.append(r_post_CTR_LIF)        r_post_FR.append(r_post_FR_LIF)        I_syn_e_CTR.append(I_syn_e_CTR_LIF)        I_syn_e_FR.append(I_syn_e_FR_LIF)    return r_post_CTR, r_post_FR, I_syn_e_CTR, I_syn_e_FR########################################### V_gap_variable runs ####################################################################################def single_V_gap_variable_run(V_gaps, model_mode, membrane_noise=0.0):    # run a single variable V_gap simulation        # input    # V_gaps is an array of voltage gaps between threshold potential & leak potential/resting potential     # model_mode is a list of strings or string & decides which model is used for simulation    # membrane_noise is the standard deviation of the membrane noise in mV/ms    # output     # results_single_run_E_L_LIF, results_single_run_V_thresh_LIF, results_single_run_E_L_AdExp, results_single_run_V_thresh_AdExp are the results dictionaries    # initialize dictionaries to save results    results_single_run_E_L_LIF, results_single_run_V_thresh_LIF, results_single_run_E_L_AdExp, results_single_run_V_thresh_AdExp = empty_results_dictionary(), empty_results_dictionary(), empty_results_dictionary(), empty_results_dictionary()        # load parameter values    # define synaptic input    N_syn, N_e, N_e_signal_ratio, N_i, rate_background_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, mu_weight_e, sigma_weight_e, mu_weight_i, sigma_weight_i = sif.synaptic_parameters(synaptic_scaling_mode='multiplicative')        # orientation variation input    w_e_0, w_i_0, spike_times_e, spike_times_i, r_e, r_i, t_stim, T, N_e_signal, N_e_noise = sif.orientation_variation_input(N_e, N_i, N_e_signal_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, rate_background_ratio, mu_weight_e, sigma_weight_e, mu_weight_i, sigma_weight_i)        # load CTR parameter values    C_m, E_L, R_m, g_L, V_thresh, V_reset, rate_window, E_e, E_i, tau_e, tau_i, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise = sim_parameters(parameter_mode='CTR', membrane_noise=membrane_noise)        # scale CTR synaptic input    w_scale_CTR = 100    w_e = w_e_0 * 5 * w_scale_CTR * 4 # low E/I balance: 4/1    w_i = w_i_0 * 5 * w_scale_CTR * 1 # low E/I balance: 4/1    # save V_gap_absolute values    V_gap_absolute_list = []        # iterate through all V_gaps    for V_gap in V_gaps:        E_L_gap = E_L + V_gap        V_reset_gap = E_L_gap        V_thresh_gap = V_thresh - V_gap        V_gap_absolute = np.abs(E_L_gap - V_thresh)        V_gap_absolute_list.append(V_gap_absolute)                # simulate LIF if given            if 'LIF' in model_mode:            # scale LIF synaptic input            w_e_LIF = w_e            w_i_LIF = w_i                        # translate CTR to Brian-readable values            T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_LIF_b, w_i_LIF_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_gap_b, V_thresh_b, V_reset_gap_b, rate_window_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, membrane_noise_b = parameters_brian(T, N_e, N_i, spike_times_e, spike_times_i, E_e, E_i, w_e_LIF, w_i_LIF, tau_e, tau_i, C_m, g_L, E_L_gap, V_thresh, V_reset_gap, rate_window, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise)             T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_LIF_b, w_i_LIF_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_b, V_thresh_gap_b, V_reset_b, rate_window_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, membrane_noise_b = parameters_brian(T, N_e, N_i, spike_times_e, spike_times_i, E_e, E_i, w_e_LIF, w_i_LIF, tau_e, tau_i, C_m, g_L, E_L, V_thresh_gap, V_reset, rate_window, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise)                         # simulate LIF            time_E_L_LIF, V_m_E_L_LIF, spike_times_post_E_L_LIF, rate_estimate_post_E_L_LIF, I_syn_e_E_L_LIF, I_syn_i_E_L_LIF, g_e_E_L_LIF, g_i_E_L_LIF = LIF(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_LIF_b, w_i_LIF_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_gap_b, V_thresh_b, V_reset_gap_b, rate_window_b, membrane_noise_b)            time_V_thresh_LIF, V_m_V_thresh_LIF, spike_times_post_V_thresh_LIF, rate_estimate_post_V_thresh_LIF, I_syn_e_V_thresh_LIF, I_syn_i_V_thresh_LIF, g_e_V_thresh_LIF, g_i_V_thresh_LIF = LIF(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_LIF_b, w_i_LIF_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_b, V_thresh_gap_b, V_reset_b, rate_window_b, membrane_noise_b)                # run full LIF analysis            r_post_E_L_LIF, E_tot_E_L_LIF, CV_V_m_E_L_LIF, tuning_curve_E_L_LIF, OSI_E_L_LIF, OSI_per_energy_E_L_LIF, CV_ISI_tuning_curve_E_L_LIF, CV_ISI_tuning_curve_per_energy_E_L_LIF, MI_tuning_curve_E_L_LIF, MI_tuning_curve_per_energy_E_L_LIF, MICE_tuning_curve_E_L_LIF, MICE_tuning_curve_per_energy_E_L_LIF, CV_ISI_E_L_LIF, CV_ISI_per_energy_E_L_LIF, MI_E_L_LIF, MI_per_energy_E_L_LIF, TE_E_L_LIF, TE_per_energy_E_L_LIF, MICE_E_L_LIF, MICE_per_energy_E_L_LIF, TECE_E_L_LIF, TECE_per_energy_E_L_LIF, E_vec_E_L_LIF = af.complete_analysis(spike_times_post_E_L_LIF, V_m_E_L_LIF, T, R_m, C_m, E_L_gap, I_syn_e_E_L_LIF, V_thresh, spike_times_e, w_e_LIF, N_e_noise)            r_post_V_thresh_LIF, E_tot_V_thresh_LIF, CV_V_m_V_thresh_LIF, tuning_curve_V_thresh_LIF, OSI_V_thresh_LIF, OSI_per_energy_V_thresh_LIF, CV_ISI_tuning_curve_V_thresh_LIF, CV_ISI_tuning_curve_per_energy_V_thresh_LIF, MI_tuning_curve_V_thresh_LIF, MI_tuning_curve_per_energy_V_thresh_LIF, MICE_tuning_curve_V_thresh_LIF, MICE_tuning_curve_per_energy_V_thresh_LIF, CV_ISI_V_thresh_LIF, CV_ISI_per_energy_V_thresh_LIF, MI_V_thresh_LIF, MI_per_energy_V_thresh_LIF, TE_V_thresh_LIF, TE_per_energy_V_thresh_LIF, MICE_V_thresh_LIF, MICE_per_energy_V_thresh_LIF, TECE_V_thresh_LIF, TECE_per_energy_V_thresh_LIF, E_vec_V_thresh_LIF = af.complete_analysis(spike_times_post_V_thresh_LIF, V_m_V_thresh_LIF, T, R_m, C_m, E_L, I_syn_e_V_thresh_LIF, V_thresh_gap, spike_times_e, w_e_LIF, N_e_noise)            # save E_L results in LIF dictionary             results_E_L_LIF = save_results_dictionary(V_m_E_L_LIF, I_syn_e_E_L_LIF, I_syn_i_E_L_LIF, spike_times_post_E_L_LIF, r_post_E_L_LIF, E_tot_E_L_LIF, CV_V_m_E_L_LIF, tuning_curve_E_L_LIF, OSI_E_L_LIF, OSI_per_energy_E_L_LIF, CV_ISI_tuning_curve_E_L_LIF, CV_ISI_tuning_curve_per_energy_E_L_LIF, MI_tuning_curve_E_L_LIF, MI_tuning_curve_per_energy_E_L_LIF, MICE_tuning_curve_E_L_LIF, MICE_tuning_curve_per_energy_E_L_LIF, CV_ISI_E_L_LIF, CV_ISI_per_energy_E_L_LIF, MI_E_L_LIF, MI_per_energy_E_L_LIF, TE_E_L_LIF, TE_per_energy_E_L_LIF, MICE_E_L_LIF, MICE_per_energy_E_L_LIF, TECE_E_L_LIF, TECE_per_energy_E_L_LIF)                        # save V_thresh results in LIF dictionary              results_V_thresh_LIF = save_results_dictionary(V_m_V_thresh_LIF, I_syn_e_V_thresh_LIF, I_syn_i_V_thresh_LIF, spike_times_post_V_thresh_LIF, r_post_V_thresh_LIF, E_tot_V_thresh_LIF, CV_V_m_V_thresh_LIF, tuning_curve_V_thresh_LIF, OSI_V_thresh_LIF, OSI_per_energy_V_thresh_LIF, CV_ISI_tuning_curve_V_thresh_LIF, CV_ISI_tuning_curve_per_energy_V_thresh_LIF, MI_tuning_curve_V_thresh_LIF, MI_tuning_curve_per_energy_V_thresh_LIF, MICE_tuning_curve_V_thresh_LIF, MICE_tuning_curve_per_energy_V_thresh_LIF, CV_ISI_V_thresh_LIF, CV_ISI_per_energy_V_thresh_LIF, MI_V_thresh_LIF, MI_per_energy_V_thresh_LIF, TE_V_thresh_LIF, TE_per_energy_V_thresh_LIF, MICE_V_thresh_LIF, MICE_per_energy_V_thresh_LIF, TECE_V_thresh_LIF, TECE_per_energy_V_thresh_LIF)                        # append values to results dictionary            for key, value in results_E_L_LIF.items():                results_single_run_E_L_LIF[key].append(value)                        for key, value in results_V_thresh_LIF.items():                results_single_run_V_thresh_LIF[key].append(value)                    # simulate AdExp if given          if 'AdExp' in model_mode:                               # scale synaptic input            weight_factor_LIF_to_AdExp = 1.0 #1.5            w_e_AdExp = w_e * weight_factor_LIF_to_AdExp            w_i_AdExp = w_i * weight_factor_LIF_to_AdExp                        # translate CTR to Brian-readable values            T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_AdExp_b, w_i_AdExp_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_gap_b, V_thresh_b, V_reset_gap_b, rate_window_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, membrane_noise_b = parameters_brian(T, N_e, N_i, spike_times_e, spike_times_i, E_e, E_i, w_e_AdExp, w_i_AdExp, tau_e, tau_i, C_m, g_L, E_L_gap, V_thresh, V_reset_gap, rate_window, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise)             T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_AdExp_b, w_i_AdExp_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_b, V_thresh_gap_b, V_reset_b, rate_window_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, membrane_noise_b = parameters_brian(T, N_e, N_i, spike_times_e, spike_times_i, E_e, E_i, w_e_AdExp, w_i_AdExp, tau_e, tau_i, C_m, g_L, E_L, V_thresh_gap, V_reset, rate_window, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise)                         # simulate AdExp            time_E_L_AdExp, V_m_E_L_AdExp, spike_times_post_E_L_AdExp, rate_estimate_post_E_L_AdExp, I_syn_e_E_L_AdExp, I_syn_i_E_L_AdExp, g_e_E_L_AdExp, g_i_E_L_AdExp = AdExp(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_AdExp_b, w_i_AdExp_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_gap_b, V_thresh_b, V_reset_gap_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, rate_window_b, membrane_noise_b)            time_V_thresh_AdExp, V_m_V_thresh_AdExp, spike_times_post_V_thresh_AdExp, rate_estimate_post_V_thresh_AdExp, I_syn_e_V_thresh_AdExp, I_syn_i_V_thresh_AdExp, g_e_V_thresh_AdExp, g_i_V_thresh_AdExp = AdExp(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_AdExp_b, w_i_AdExp_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_b, V_thresh_gap_b, V_reset_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, rate_window_b, membrane_noise_b)                # run full AdExp analysis            r_post_E_L_AdExp, E_tot_E_L_AdExp, CV_V_m_E_L_AdExp, tuning_curve_E_L_AdExp, OSI_E_L_AdExp, OSI_per_energy_E_L_AdExp, CV_ISI_tuning_curve_E_L_AdExp, CV_ISI_tuning_curve_per_energy_E_L_AdExp, MI_tuning_curve_E_L_AdExp, MI_tuning_curve_per_energy_E_L_AdExp, MICE_tuning_curve_E_L_AdExp, MICE_tuning_curve_per_energy_E_L_AdExp, CV_ISI_E_L_AdExp, CV_ISI_per_energy_E_L_AdExp, MI_E_L_AdExp, MI_per_energy_E_L_AdExp, TE_E_L_AdExp, TE_per_energy_E_L_AdExp, MICE_E_L_AdExp, MICE_per_energy_E_L_AdExp, TECE_E_L_AdExp, TECE_per_energy_E_L_AdExp, E_vec_E_L_AdExp = af.complete_analysis(spike_times_post_E_L_AdExp, V_m_E_L_AdExp, T, R_m, C_m, E_L_gap, I_syn_e_E_L_AdExp, V_thresh, spike_times_e, w_e_AdExp, N_e_noise)            r_post_V_thresh_AdExp, E_tot_V_thresh_AdExp, CV_V_m_V_thresh_AdExp, tuning_curve_V_thresh_AdExp, OSI_V_thresh_AdExp, OSI_per_energy_V_thresh_AdExp, CV_ISI_tuning_curve_V_thresh_AdExp, CV_ISI_tuning_curve_per_energy_V_thresh_AdExp, MI_tuning_curve_V_thresh_AdExp, MI_tuning_curve_per_energy_V_thresh_AdExp, MICE_tuning_curve_V_thresh_AdExp, MICE_tuning_curve_per_energy_V_thresh_AdExp, CV_ISI_V_thresh_AdExp, CV_ISI_per_energy_V_thresh_AdExp, MI_V_thresh_AdExp, MI_per_energy_V_thresh_AdExp, TE_V_thresh_AdExp, TE_per_energy_V_thresh_AdExp, MICE_V_thresh_AdExp, MICE_per_energy_V_thresh_AdExp, TECE_V_thresh_AdExp, TECE_per_energy_V_thresh_AdExp, E_vec_V_thresh_AdExp = af.complete_analysis(spike_times_post_V_thresh_AdExp, V_m_V_thresh_AdExp, T, R_m, C_m, E_L, I_syn_e_V_thresh_AdExp, V_thresh_gap, spike_times_e, w_e_AdExp, N_e_noise)            # save E_L results in AdExp dictionary             results_E_L_AdExp = save_results_dictionary(V_m_E_L_AdExp, I_syn_e_E_L_AdExp, I_syn_i_E_L_AdExp, spike_times_post_E_L_AdExp, r_post_E_L_AdExp, E_tot_E_L_AdExp, CV_V_m_E_L_AdExp, tuning_curve_E_L_AdExp, OSI_E_L_AdExp, OSI_per_energy_E_L_AdExp, CV_ISI_tuning_curve_E_L_AdExp, CV_ISI_tuning_curve_per_energy_E_L_AdExp, MI_tuning_curve_E_L_AdExp, MI_tuning_curve_per_energy_E_L_AdExp, MICE_tuning_curve_E_L_AdExp, MICE_tuning_curve_per_energy_E_L_AdExp, CV_ISI_E_L_AdExp, CV_ISI_per_energy_E_L_AdExp, MI_E_L_AdExp, MI_per_energy_E_L_AdExp, TE_E_L_AdExp, TE_per_energy_E_L_AdExp, MICE_E_L_AdExp, MICE_per_energy_E_L_AdExp, TECE_E_L_AdExp, TECE_per_energy_E_L_AdExp)                # save V_thresh results in AdExp dictionary              results_V_thresh_AdExp = save_results_dictionary(V_m_V_thresh_AdExp, I_syn_e_V_thresh_AdExp, I_syn_i_V_thresh_AdExp, spike_times_post_V_thresh_AdExp, r_post_V_thresh_AdExp, E_tot_V_thresh_AdExp, CV_V_m_V_thresh_AdExp, tuning_curve_V_thresh_AdExp, OSI_V_thresh_AdExp, OSI_per_energy_V_thresh_AdExp, CV_ISI_tuning_curve_V_thresh_AdExp, CV_ISI_tuning_curve_per_energy_V_thresh_AdExp, MI_tuning_curve_V_thresh_AdExp, MI_tuning_curve_per_energy_V_thresh_AdExp, MICE_tuning_curve_V_thresh_AdExp, MICE_tuning_curve_per_energy_V_thresh_AdExp, CV_ISI_V_thresh_AdExp, CV_ISI_per_energy_V_thresh_AdExp, MI_V_thresh_AdExp, MI_per_energy_V_thresh_AdExp, TE_V_thresh_AdExp, TE_per_energy_V_thresh_AdExp, MICE_V_thresh_AdExp, MICE_per_energy_V_thresh_AdExp, TECE_V_thresh_AdExp, TECE_per_energy_V_thresh_AdExp)                        # append values to results dictionary            for key, value in results_E_L_AdExp.items():                results_single_run_E_L_AdExp[key].append(value)                        for key, value in results_V_thresh_AdExp.items():                results_single_run_V_thresh_AdExp[key].append(value)        # add V_gap_absolute_list to results dictionary    results_single_run_E_L_LIF['V_gap_absolute_list'] = V_gap_absolute_list    results_single_run_V_thresh_LIF['V_gap_absolute_list'] = V_gap_absolute_list    results_single_run_E_L_AdExp['V_gap_absolute_list'] = V_gap_absolute_list    results_single_run_V_thresh_AdExp['V_gap_absolute_list'] = V_gap_absolute_list        return results_single_run_E_L_LIF, results_single_run_V_thresh_LIF, results_single_run_E_L_AdExp, results_single_run_V_thresh_AdExpdef multiple_V_gap_variable_runs(number_V_gap_runs, V_gaps, model_mode, membrane_noise=0.0, savename=None):     # run multiple variable V_gap simulation        # input    # number_V_gap_runs is the number of V_gap runs to perform    # V_gaps is an array of voltage gaps between threshold potential & leak potential/resting potential     # model_mode is a list of strings or string & decides which model is used for simulation    # mmembrane_noise is the std of the membrane noise in mV/ms    # output     # results_multiple_run_E_L_LIF, results_multiple_run_V_thresh_LIF, results_multiple_run_E_L_AdExp, results_multiple_run_V_thresh_AdExp are the results dictionaries    # initialize dictionaries to save results    results_multiple_runs_E_L_LIF, results_multiple_runs_V_thresh_LIF, results_multiple_runs_E_L_AdExp, results_multiple_runs_V_thresh_AdExp = empty_results_dictionary(), empty_results_dictionary(), empty_results_dictionary(), empty_results_dictionary()    results_multiple_runs_E_L_LIF['V_gap_absolute_list'] = []    results_multiple_runs_V_thresh_LIF['V_gap_absolute_list'] = []    results_multiple_runs_E_L_AdExp['V_gap_absolute_list'] = []    results_multiple_runs_V_thresh_AdExp['V_gap_absolute_list'] = []        # simulate number_V_gap_runs times and save results in results dictionary    for run_number in range(number_V_gap_runs):        results_single_run_E_L_LIF, results_single_run_V_thresh_LIF, results_single_run_E_L_AdExp, results_single_run_V_thresh_AdExp = single_V_gap_variable_run(V_gaps, model_mode=model_mode, membrane_noise=membrane_noise)        for key, value in results_single_run_E_L_LIF.items():            results_multiple_runs_E_L_LIF[key].append(value)                for key, value in results_single_run_V_thresh_LIF.items():            results_multiple_runs_V_thresh_LIF[key].append(value)                for key, value in results_single_run_E_L_AdExp.items():            results_multiple_runs_E_L_AdExp[key].append(value)                for key, value in results_single_run_V_thresh_AdExp.items():            results_multiple_runs_V_thresh_AdExp[key].append(value)                results_multiple_V_gap_variable_runs_LIF = [results_multiple_runs_E_L_LIF, results_multiple_runs_V_thresh_LIF]    results_multiple_V_gap_variable_runs_AdExp = [results_multiple_runs_E_L_AdExp, results_multiple_runs_V_thresh_AdExp]        # save results if savename is provided    if savename is not None:        with open(f'{savename}_results_multiple_V_gap_variable_runs_LIF.pkl', 'wb') as f:            pickle.dump(results_multiple_V_gap_variable_runs_LIF, f)        with open(f'{savename}_results_multiple_V_gap_variable_runs_AdExp.pkl', 'wb') as f:            pickle.dump(results_multiple_V_gap_variable_runs_AdExp, f)        return results_multiple_V_gap_variable_runs_LIF, results_multiple_V_gap_variable_runs_AdExpdef single_V_gap_variable_E_e_E_i_run(V_gaps, model_mode, membrane_noise=0.0):    # run a single variable V_gap simulation to test the effects of E_e & E_i        # input    # V_gaps is an array of voltage gaps between threshold potential & leak potential/resting potential     # model_mode is a list of strings or string & decides which model is used for simulation    # membrane_noise is the standard deviation of the membrane noise in mV/ms    # output     # results_single_run_E_L_LIF, results_single_run_V_thresh_LIF, results_single_run_E_L_AdExp, results_single_run_V_thresh_AdExp are the results dictionaries    # initialize dictionaries to save results    results_single_run_E_L_LIF, results_single_run_V_thresh_LIF, results_single_run_E_L_AdExp, results_single_run_V_thresh_AdExp = empty_results_dictionary(), empty_results_dictionary(), empty_results_dictionary(), empty_results_dictionary()        # load parameter values    # define synaptic input    N_syn, N_e, N_e_signal_ratio, N_i, rate_background_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, mu_weight_e, sigma_weight_e, mu_weight_i, sigma_weight_i = sif.synaptic_parameters(synaptic_scaling_mode='multiplicative')        # orientation variation input    w_e_0, w_i_0, spike_times_e, spike_times_i, r_e, r_i, t_stim, T, N_e_signal, N_e_noise = sif.orientation_variation_input(N_e, N_i, N_e_signal_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, rate_background_ratio, mu_weight_e, sigma_weight_e, mu_weight_i, sigma_weight_i)        # load CTR parameter values    C_m, E_L, R_m, g_L, V_thresh, V_reset, rate_window, E_e, E_i, tau_e, tau_i, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise = sim_parameters(parameter_mode='CTR', membrane_noise=membrane_noise)        # scale CTR synaptic input    w_scale_CTR = 100    w_e = w_e_0 * 5 * w_scale_CTR * 4 # low E/I balance: 4/1    w_i = w_i_0 * 5 * w_scale_CTR * 1 # low E/I balance: 4/1    # save V_gap_absolute values    V_gap_absolute_list = []        # iterate through all V_gaps    for V_gap in V_gaps:        E_L_gap = E_L + V_gap        V_reset_gap = E_L_gap        V_thresh_gap = V_thresh - V_gap        V_gap_absolute = np.abs(E_L_gap - V_thresh)        V_gap_absolute_list.append(V_gap_absolute)                # simulate LIF if given            if 'LIF' in model_mode:            # scale LIF synaptic input            w_e_LIF = w_e            w_i_LIF = w_i            # translate CTR to Brian-readable values            T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_LIF_b, w_i_LIF_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_gap_b, V_thresh_b, V_reset_gap_b, rate_window_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, membrane_noise_b = parameters_brian(T, N_e, N_i, spike_times_e, spike_times_i, E_e, E_i, w_e_LIF, w_i_LIF, tau_e, tau_i, C_m, g_L, E_L_gap, V_thresh, V_reset_gap, rate_window, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise)             T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_LIF_b, w_i_LIF_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_b, V_thresh_gap_b, V_reset_b, rate_window_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, membrane_noise_b = parameters_brian(T, N_e, N_i, spike_times_e, spike_times_i, E_e, E_i, w_e_LIF, w_i_LIF, tau_e, tau_i, C_m, g_L, E_L, V_thresh_gap, V_reset, rate_window, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise)             # simulate LIF            time_E_L_LIF, V_m_E_L_LIF, spike_times_post_E_L_LIF, rate_estimate_post_E_L_LIF, I_syn_e_E_L_LIF, I_syn_i_E_L_LIF, g_e_E_L_LIF, g_i_E_L_LIF = LIF(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_LIF_b, w_i_LIF_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_gap_b, V_thresh_b, V_reset_gap_b, rate_window_b, membrane_noise_b)            time_V_thresh_LIF, V_m_V_thresh_LIF, spike_times_post_V_thresh_LIF, rate_estimate_post_V_thresh_LIF, I_syn_e_V_thresh_LIF, I_syn_i_V_thresh_LIF, g_e_V_thresh_LIF, g_i_V_thresh_LIF = LIF(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_LIF_b, w_i_LIF_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_b, V_thresh_gap_b, V_reset_b, rate_window_b, membrane_noise_b)                # run full LIF analysis            r_post_E_L_LIF, E_tot_E_L_LIF, CV_V_m_E_L_LIF, tuning_curve_E_L_LIF, OSI_E_L_LIF, OSI_per_energy_E_L_LIF, CV_ISI_tuning_curve_E_L_LIF, CV_ISI_tuning_curve_per_energy_E_L_LIF, MI_tuning_curve_E_L_LIF, MI_tuning_curve_per_energy_E_L_LIF, MICE_tuning_curve_E_L_LIF, MICE_tuning_curve_per_energy_E_L_LIF, CV_ISI_E_L_LIF, CV_ISI_per_energy_E_L_LIF, MI_E_L_LIF, MI_per_energy_E_L_LIF, TE_E_L_LIF, TE_per_energy_E_L_LIF, MICE_E_L_LIF, MICE_per_energy_E_L_LIF, TECE_E_L_LIF, TECE_per_energy_E_L_LIF, E_vec_E_L_LIF = af.complete_analysis(spike_times_post_E_L_LIF, V_m_E_L_LIF, T, R_m, C_m, E_L_gap, I_syn_e_E_L_LIF, V_thresh, spike_times_e, w_e_LIF, N_e_noise)            r_post_V_thresh_LIF, E_tot_V_thresh_LIF, CV_V_m_V_thresh_LIF, tuning_curve_V_thresh_LIF, OSI_V_thresh_LIF, OSI_per_energy_V_thresh_LIF, CV_ISI_tuning_curve_V_thresh_LIF, CV_ISI_tuning_curve_per_energy_V_thresh_LIF, MI_tuning_curve_V_thresh_LIF, MI_tuning_curve_per_energy_V_thresh_LIF, MICE_tuning_curve_V_thresh_LIF, MICE_tuning_curve_per_energy_V_thresh_LIF, CV_ISI_V_thresh_LIF, CV_ISI_per_energy_V_thresh_LIF, MI_V_thresh_LIF, MI_per_energy_V_thresh_LIF, TE_V_thresh_LIF, TE_per_energy_V_thresh_LIF, MICE_V_thresh_LIF, MICE_per_energy_V_thresh_LIF, TECE_V_thresh_LIF, TECE_per_energy_V_thresh_LIF, E_vec_V_thresh_LIF = af.complete_analysis(spike_times_post_V_thresh_LIF, V_m_V_thresh_LIF, T, R_m, C_m, E_L, I_syn_e_V_thresh_LIF, V_thresh_gap, spike_times_e, w_e_LIF, N_e_noise)            # simulate LIF with E_e + 100 mV            E_e_new = E_e + 10            E_e_new_b = E_e_b + 10*mV            time_E_L_E_e_LIF, V_m_E_L_E_e_LIF, spike_times_post_E_L_E_e_LIF, rate_estimate_post_E_L_E_e_LIF, I_syn_e_E_L_E_e_LIF, I_syn_i_E_L_E_e_LIF, g_e_E_L_E_e_LIF, g_i_E_L_E_e_LIF = LIF(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_new_b, E_i_b, w_e_LIF_b, w_i_LIF_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_gap_b, V_thresh_b, V_reset_gap_b, rate_window_b, membrane_noise_b)            time_V_thresh_E_e_LIF, V_m_V_thresh_E_e_LIF, spike_times_post_V_thresh_E_e_LIF, rate_estimate_post_V_thresh_E_e_LIF, I_syn_e_V_thresh_E_e_LIF, I_syn_i_V_thresh_E_e_LIF, g_e_V_thresh_E_e_LIF, g_i_V_thresh_E_e_LIF = LIF(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_new_b, E_i_b, w_e_LIF_b, w_i_LIF_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_b, V_thresh_gap_b, V_reset_b, rate_window_b, membrane_noise_b)                        # run full LIF analysis with E_e + 100 mV            r_post_E_L_E_e_LIF, E_tot_E_L_E_e_LIF, CV_V_m_E_L_E_e_LIF, tuning_curve_E_L_E_e_LIF, OSI_E_L_E_e_LIF, OSI_per_energy_E_L_E_e_LIF, CV_ISI_tuning_curve_E_L_E_e_LIF, CV_ISI_tuning_curve_per_energy_E_L_E_e_LIF, MI_tuning_curve_E_L_E_e_LIF, MI_tuning_curve_per_energy_E_L_E_e_LIF, MICE_tuning_curve_E_L_E_e_LIF, MICE_tuning_curve_per_energy_E_L_E_e_LIF, CV_ISI_E_L_E_e_LIF, CV_ISI_per_energy_E_L_E_e_LIF, MI_E_L_E_e_LIF, MI_per_energy_E_L_E_e_LIF, TE_E_L_E_e_LIF, TE_per_energy_E_L_E_e_LIF, MICE_E_L_E_e_LIF, MICE_per_energy_E_L_E_e_LIF, TECE_E_L_E_e_LIF, TECE_per_energy_E_L_E_e_LIF, E_vec_E_L_E_e_LIF = af.complete_analysis(spike_times_post_E_L_E_e_LIF, V_m_E_L_E_e_LIF, T, R_m, C_m, E_L_gap, I_syn_e_E_L_E_e_LIF, V_thresh, spike_times_e, w_e_LIF, N_e_noise)            r_post_V_thresh_E_e_LIF, E_tot_V_thresh_E_e_LIF, CV_V_m_V_thresh_E_e_LIF, tuning_curve_V_thresh_E_e_LIF, OSI_V_thresh_E_e_LIF, OSI_per_energy_V_thresh_E_e_LIF, CV_ISI_tuning_curve_V_thresh_E_e_LIF, CV_ISI_tuning_curve_per_energy_V_thresh_E_e_LIF, MI_tuning_curve_V_thresh_E_e_LIF, MI_tuning_curve_per_energy_V_thresh_E_e_LIF, MICE_tuning_curve_V_thresh_E_e_LIF, MICE_tuning_curve_per_energy_V_thresh_E_e_LIF, CV_ISI_V_thresh_E_e_LIF, CV_ISI_per_energy_V_thresh_E_e_LIF, MI_V_thresh_E_e_LIF, MI_per_energy_V_thresh_E_e_LIF, TE_V_thresh_E_e_LIF, TE_per_energy_V_thresh_E_e_LIF, MICE_V_thresh_E_e_LIF, MICE_per_energy_V_thresh_E_e_LIF, TECE_V_thresh_E_e_LIF, TECE_per_energy_V_thresh_E_e_LIF, E_vec_V_thresh_E_e_LIF = af.complete_analysis(spike_times_post_V_thresh_E_e_LIF, V_m_V_thresh_E_e_LIF, T, R_m, C_m, E_L, I_syn_e_V_thresh_E_e_LIF, V_thresh_gap, spike_times_e, w_e_LIF, N_e_noise)            # simulate LIF with E_i - 100 mV            E_i_new = E_i - 10            E_i_new_b = E_i_b - 10*mV            time_E_L_E_i_LIF, V_m_E_L_E_i_LIF, spike_times_post_E_L_E_i_LIF, rate_estimate_post_E_L_E_i_LIF, I_syn_e_E_L_E_i_LIF, I_syn_i_E_L_E_i_LIF, g_e_E_L_E_i_LIF, g_i_E_L_E_i_LIF = LIF(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_new_b, w_e_LIF_b, w_i_LIF_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_gap_b, V_thresh_b, V_reset_gap_b, rate_window_b, membrane_noise_b)            time_V_thresh_E_i_LIF, V_m_V_thresh_E_i_LIF, spike_times_post_V_thresh_E_i_LIF, rate_estimate_post_V_thresh_E_i_LIF, I_syn_e_V_thresh_E_i_LIF, I_syn_i_V_thresh_E_i_LIF, g_e_V_thresh_E_i_LIF, g_i_V_thresh_E_i_LIF = LIF(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_new_b, w_e_LIF_b, w_i_LIF_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_b, V_thresh_gap_b, V_reset_b, rate_window_b, membrane_noise_b)                          # run full LIF analysis with E_i - 100 mV            r_post_E_L_E_i_LIF, E_tot_E_L_E_i_LIF, CV_V_m_E_L_E_i_LIF, tuning_curve_E_L_E_i_LIF, OSI_E_L_E_i_LIF, OSI_per_energy_E_L_E_i_LIF, CV_ISI_tuning_curve_E_L_E_i_LIF, CV_ISI_tuning_curve_per_energy_E_L_E_i_LIF, MI_tuning_curve_E_L_E_i_LIF, MI_tuning_curve_per_energy_E_L_E_i_LIF, MICE_tuning_curve_E_L_E_i_LIF, MICE_tuning_curve_per_energy_E_L_E_i_LIF, CV_ISI_E_L_E_i_LIF, CV_ISI_per_energy_E_L_E_i_LIF, MI_E_L_E_i_LIF, MI_per_energy_E_L_E_i_LIF, TE_E_L_E_i_LIF, TE_per_energy_E_L_E_i_LIF, MICE_E_L_E_i_LIF, MICE_per_energy_E_L_E_i_LIF, TECE_E_L_E_i_LIF, TECE_per_energy_E_L_E_i_LIF, E_vec_E_L_E_i_LIF = af.complete_analysis(spike_times_post_E_L_E_i_LIF, V_m_E_L_E_i_LIF, T, R_m, C_m, E_L_gap, I_syn_e_E_L_E_i_LIF, V_thresh, spike_times_e, w_e_LIF, N_e_noise)            r_post_V_thresh_E_i_LIF, E_tot_V_thresh_E_i_LIF, CV_V_m_V_thresh_E_i_LIF, tuning_curve_V_thresh_E_i_LIF, OSI_V_thresh_E_i_LIF, OSI_per_energy_V_thresh_E_i_LIF, CV_ISI_tuning_curve_V_thresh_E_i_LIF, CV_ISI_tuning_curve_per_energy_V_thresh_E_i_LIF, MI_tuning_curve_V_thresh_E_i_LIF, MI_tuning_curve_per_energy_V_thresh_E_i_LIF, MICE_tuning_curve_V_thresh_E_i_LIF, MICE_tuning_curve_per_energy_V_thresh_E_i_LIF, CV_ISI_V_thresh_E_i_LIF, CV_ISI_per_energy_V_thresh_E_i_LIF, MI_V_thresh_E_i_LIF, MI_per_energy_V_thresh_E_i_LIF, TE_V_thresh_E_i_LIF, TE_per_energy_V_thresh_E_i_LIF, MICE_V_thresh_E_i_LIF, MICE_per_energy_V_thresh_E_i_LIF, TECE_V_thresh_E_i_LIF, TECE_per_energy_V_thresh_E_i_LIF, E_vec_V_thresh_E_i_LIF = af.complete_analysis(spike_times_post_V_thresh_E_i_LIF, V_m_V_thresh_E_i_LIF, T, R_m, C_m, E_L, I_syn_e_V_thresh_E_i_LIF, V_thresh_gap, spike_times_e, w_e_LIF, N_e_noise)                           # save E_L results in LIF dictionary             results_E_L_LIF = {                'V_m': [np.mean(V_m_E_L_LIF), np.mean(V_m_E_L_E_e_LIF), np.mean(V_m_E_L_E_i_LIF)],                'I_syn_e': [np.mean(I_syn_e_E_L_LIF), np.mean(I_syn_e_E_L_E_e_LIF), np.mean(I_syn_e_E_L_E_i_LIF)],                'I_syn_i': [np.mean(I_syn_i_E_L_LIF), np.mean(I_syn_i_E_L_E_e_LIF), np.mean(I_syn_i_E_L_E_i_LIF)],                'spike_times_post': [spike_times_post_E_L_LIF, spike_times_post_E_L_E_e_LIF, spike_times_post_E_L_E_i_LIF],                'r_post': [r_post_E_L_LIF, r_post_E_L_E_e_LIF, r_post_E_L_E_i_LIF],                'E_tot': [E_tot_E_L_LIF, E_tot_E_L_E_e_LIF, E_tot_E_L_E_i_LIF],                'tuning_curve': [tuning_curve_E_L_LIF, tuning_curve_E_L_E_e_LIF, tuning_curve_E_L_E_i_LIF],                'CV_V_m': [CV_V_m_E_L_LIF, CV_V_m_E_L_E_e_LIF, CV_V_m_E_L_E_i_LIF],                'OSI': [OSI_E_L_LIF, OSI_E_L_E_e_LIF, OSI_E_L_E_i_LIF],                'OSI_per_energy': [OSI_per_energy_E_L_LIF, OSI_per_energy_E_L_E_e_LIF, OSI_per_energy_E_L_E_i_LIF],                'CV_ISI_tuning_curve': [CV_ISI_tuning_curve_E_L_LIF, CV_ISI_tuning_curve_E_L_E_e_LIF, CV_ISI_tuning_curve_E_L_E_i_LIF],                'CV_ISI_tuning_curve_per_energy': [CV_ISI_tuning_curve_per_energy_E_L_LIF, CV_ISI_tuning_curve_per_energy_E_L_E_e_LIF, CV_ISI_tuning_curve_per_energy_E_L_E_i_LIF],                'MI_tuning_curve': [MI_tuning_curve_E_L_LIF, MI_tuning_curve_E_L_E_e_LIF, MI_tuning_curve_E_L_E_i_LIF],                'MI_tuning_curve_per_energy': [MI_tuning_curve_per_energy_E_L_LIF, MI_tuning_curve_per_energy_E_L_E_e_LIF, MI_tuning_curve_per_energy_E_L_E_i_LIF],                'MICE_tuning_curve': [MICE_tuning_curve_E_L_LIF, MICE_tuning_curve_E_L_E_e_LIF, MICE_tuning_curve_E_L_E_i_LIF],                'MICE_tuning_curve_per_energy': [MICE_tuning_curve_per_energy_E_L_LIF, MICE_tuning_curve_per_energy_E_L_E_e_LIF, MICE_tuning_curve_per_energy_E_L_E_i_LIF],                'CV_ISI': [CV_ISI_E_L_LIF, CV_ISI_E_L_E_e_LIF, CV_ISI_E_L_E_i_LIF],                'CV_ISI_per_energy': [CV_ISI_per_energy_E_L_LIF, CV_ISI_per_energy_E_L_E_e_LIF, CV_ISI_per_energy_E_L_E_i_LIF],                'MI': [MI_E_L_LIF, MI_E_L_E_e_LIF, MI_E_L_E_i_LIF],                'MI_per_energy': [MI_per_energy_E_L_LIF, MI_per_energy_E_L_E_e_LIF, MI_per_energy_E_L_E_i_LIF],                'TE': [TE_E_L_LIF, TE_E_L_E_e_LIF, TE_E_L_E_i_LIF],                'TE_per_energy': [TE_per_energy_E_L_LIF, TE_per_energy_E_L_E_e_LIF, TE_per_energy_E_L_E_i_LIF],                'MICE': [MICE_E_L_LIF, MICE_E_L_E_e_LIF, MICE_E_L_E_i_LIF],                'MICE_per_energy': [MICE_per_energy_E_L_LIF, MICE_per_energy_E_L_E_e_LIF, MICE_per_energy_E_L_E_i_LIF],                'TECE': [TECE_E_L_LIF, TECE_E_L_E_e_LIF, TECE_E_L_E_i_LIF],                'TECE_per_energy': [TECE_per_energy_E_L_LIF, TECE_per_energy_E_L_E_e_LIF, TECE_per_energy_E_L_E_i_LIF]}                        results_V_thresh_LIF = {                'V_m': [np.mean(V_m_V_thresh_LIF), np.mean(V_m_V_thresh_E_e_LIF), np.mean(V_m_V_thresh_E_i_LIF)],                'I_syn_e': [np.mean(I_syn_e_V_thresh_LIF), np.mean(I_syn_e_V_thresh_E_e_LIF), np.mean(I_syn_e_V_thresh_E_i_LIF)],                'I_syn_i': [np.mean(I_syn_i_V_thresh_LIF), np.mean(I_syn_i_V_thresh_E_e_LIF), np.mean(I_syn_i_V_thresh_E_i_LIF)],                'spike_times_post': [spike_times_post_V_thresh_LIF, spike_times_post_V_thresh_E_e_LIF, spike_times_post_V_thresh_E_i_LIF],                'r_post': [r_post_V_thresh_LIF, r_post_V_thresh_E_e_LIF, r_post_V_thresh_E_i_LIF],                'E_tot': [E_tot_V_thresh_LIF, E_tot_V_thresh_E_e_LIF, E_tot_V_thresh_E_i_LIF],                'tuning_curve': [tuning_curve_V_thresh_LIF, tuning_curve_V_thresh_E_e_LIF, tuning_curve_V_thresh_E_i_LIF],                'CV_V_m': [CV_V_m_V_thresh_LIF, CV_V_m_V_thresh_E_e_LIF, CV_V_m_V_thresh_E_i_LIF],                'OSI': [OSI_V_thresh_LIF, OSI_V_thresh_E_e_LIF, OSI_V_thresh_E_i_LIF],                'OSI_per_energy': [OSI_per_energy_V_thresh_LIF, OSI_per_energy_V_thresh_E_e_LIF, OSI_per_energy_V_thresh_E_i_LIF],                'CV_ISI_tuning_curve': [CV_ISI_tuning_curve_V_thresh_LIF, CV_ISI_tuning_curve_V_thresh_E_e_LIF, CV_ISI_tuning_curve_V_thresh_E_i_LIF],                'CV_ISI_tuning_curve_per_energy': [CV_ISI_tuning_curve_per_energy_V_thresh_LIF, CV_ISI_tuning_curve_per_energy_V_thresh_E_e_LIF, CV_ISI_tuning_curve_per_energy_V_thresh_E_i_LIF],                'MI_tuning_curve': [MI_tuning_curve_V_thresh_LIF, MI_tuning_curve_V_thresh_E_e_LIF, MI_tuning_curve_V_thresh_E_i_LIF],                'MI_tuning_curve_per_energy': [MI_tuning_curve_per_energy_V_thresh_LIF, MI_tuning_curve_per_energy_V_thresh_E_e_LIF, MI_tuning_curve_per_energy_V_thresh_E_i_LIF],                'MICE_tuning_curve': [MICE_tuning_curve_V_thresh_LIF, MICE_tuning_curve_V_thresh_E_e_LIF, MICE_tuning_curve_V_thresh_E_i_LIF],                'MICE_tuning_curve_per_energy': [MICE_tuning_curve_per_energy_V_thresh_LIF, MICE_tuning_curve_per_energy_V_thresh_E_e_LIF, MICE_tuning_curve_per_energy_V_thresh_E_i_LIF],                'CV_ISI': [CV_ISI_V_thresh_LIF, CV_ISI_V_thresh_E_e_LIF, CV_ISI_V_thresh_E_i_LIF],                'CV_ISI_per_energy': [CV_ISI_per_energy_V_thresh_LIF, CV_ISI_per_energy_V_thresh_E_e_LIF, CV_ISI_per_energy_V_thresh_E_i_LIF],                'MI': [MI_V_thresh_LIF, MI_V_thresh_E_e_LIF, MI_V_thresh_E_i_LIF],                'MI_per_energy': [MI_per_energy_V_thresh_LIF, MI_per_energy_V_thresh_E_e_LIF, MI_per_energy_V_thresh_E_i_LIF],                'TE': [TE_V_thresh_LIF, TE_V_thresh_E_e_LIF, TE_V_thresh_E_i_LIF],                'TE_per_energy': [TE_per_energy_V_thresh_LIF, TE_per_energy_V_thresh_E_e_LIF, TE_per_energy_V_thresh_E_i_LIF],                'MICE': [MICE_V_thresh_LIF, MICE_V_thresh_E_e_LIF, MICE_V_thresh_E_i_LIF],                'MICE_per_energy': [MICE_per_energy_V_thresh_LIF, MICE_per_energy_V_thresh_E_e_LIF, MICE_per_energy_V_thresh_E_i_LIF],                'TECE': [TECE_V_thresh_LIF, TECE_V_thresh_E_e_LIF, TECE_V_thresh_E_i_LIF],                'TECE_per_energy': [TECE_per_energy_V_thresh_LIF, TECE_per_energy_V_thresh_E_e_LIF, TECE_per_energy_V_thresh_E_i_LIF]}                        # append values to results dictionary            for key, value in results_E_L_LIF.items():                results_single_run_E_L_LIF[key].append(value)                        for key, value in results_V_thresh_LIF.items():                results_single_run_V_thresh_LIF[key].append(value)                    # simulate AdExp if given          if 'AdExp' in model_mode:                               # scale synaptic input            weight_factor_LIF_to_AdExp = 1.0 #1.5            w_e_AdExp = w_e * weight_factor_LIF_to_AdExp            w_i_AdExp = w_i * weight_factor_LIF_to_AdExp                        # translate CTR to Brian-readable values            T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_AdExp_b, w_i_AdExp_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_gap_b, V_thresh_b, V_reset_gap_b, rate_window_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, membrane_noise_b = parameters_brian(T, N_e, N_i, spike_times_e, spike_times_i, E_e, E_i, w_e_AdExp, w_i_AdExp, tau_e, tau_i, C_m, g_L, E_L_gap, V_thresh, V_reset_gap, rate_window, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise)             T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_AdExp_b, w_i_AdExp_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_b, V_thresh_gap_b, V_reset_b, rate_window_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, membrane_noise_b = parameters_brian(T, N_e, N_i, spike_times_e, spike_times_i, E_e, E_i, w_e_AdExp, w_i_AdExp, tau_e, tau_i, C_m, g_L, E_L, V_thresh_gap, V_reset, rate_window, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise)             # simulate AdExp            time_E_L_AdExp, V_m_E_L_AdExp, spike_times_post_E_L_AdExp, rate_estimate_post_E_L_AdExp, I_syn_e_E_L_AdExp, I_syn_i_E_L_AdExp, g_e_E_L_AdExp, g_i_E_L_AdExp = AdExp(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_AdExp_b, w_i_AdExp_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_gap_b, V_thresh_b, V_reset_gap_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, rate_window_b, membrane_noise_b)            time_V_thresh_AdExp, V_m_V_thresh_AdExp, spike_times_post_V_thresh_AdExp, rate_estimate_post_V_thresh_AdExp, I_syn_e_V_thresh_AdExp, I_syn_i_V_thresh_AdExp, g_e_V_thresh_AdExp, g_i_V_thresh_AdExp = AdExp(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_AdExp_b, w_i_AdExp_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_b, V_thresh_gap_b, V_reset_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, rate_window_b, membrane_noise_b)                # run full AdExp analysis            r_post_E_L_AdExp, E_tot_E_L_AdExp, CV_V_m_E_L_AdExp, tuning_curve_E_L_AdExp, OSI_E_L_AdExp, OSI_per_energy_E_L_AdExp, CV_ISI_tuning_curve_E_L_AdExp, CV_ISI_tuning_curve_per_energy_E_L_AdExp, MI_tuning_curve_E_L_AdExp, MI_tuning_curve_per_energy_E_L_AdExp, MICE_tuning_curve_E_L_AdExp, MICE_tuning_curve_per_energy_E_L_AdExp, CV_ISI_E_L_AdExp, CV_ISI_per_energy_E_L_AdExp, MI_E_L_AdExp, MI_per_energy_E_L_AdExp, TE_E_L_AdExp, TE_per_energy_E_L_AdExp, MICE_E_L_AdExp, MICE_per_energy_E_L_AdExp, TECE_E_L_AdExp, TECE_per_energy_E_L_AdExp, E_vec_E_L_AdExp = af.complete_analysis(spike_times_post_E_L_AdExp, V_m_E_L_AdExp, T, R_m, C_m, E_L_gap, I_syn_e_E_L_AdExp, V_thresh, spike_times_e, w_e_AdExp, N_e_noise)            r_post_V_thresh_AdExp, E_tot_V_thresh_AdExp, CV_V_m_V_thresh_AdExp, tuning_curve_V_thresh_AdExp, OSI_V_thresh_AdExp, OSI_per_energy_V_thresh_AdExp, CV_ISI_tuning_curve_V_thresh_AdExp, CV_ISI_tuning_curve_per_energy_V_thresh_AdExp, MI_tuning_curve_V_thresh_AdExp, MI_tuning_curve_per_energy_V_thresh_AdExp, MICE_tuning_curve_V_thresh_AdExp, MICE_tuning_curve_per_energy_V_thresh_AdExp, CV_ISI_V_thresh_AdExp, CV_ISI_per_energy_V_thresh_AdExp, MI_V_thresh_AdExp, MI_per_energy_V_thresh_AdExp, TE_V_thresh_AdExp, TE_per_energy_V_thresh_AdExp, MICE_V_thresh_AdExp, MICE_per_energy_V_thresh_AdExp, TECE_V_thresh_AdExp, TECE_per_energy_V_thresh_AdExp, E_vec_V_thresh_AdExp = af.complete_analysis(spike_times_post_V_thresh_AdExp, V_m_V_thresh_AdExp, T, R_m, C_m, E_L, I_syn_e_V_thresh_AdExp, V_thresh_gap, spike_times_e, w_e_AdExp, N_e_noise)                                                                     # simulate AdExp with E_e + 100 mV            E_e_new = E_e + 10            E_e_new_b = E_e_b + 10*mV            time_E_L_E_e_AdExp, V_m_E_L_E_e_AdExp, spike_times_post_E_L_E_e_AdExp, rate_estimate_post_E_L_E_e_AdExp, I_syn_e_E_L_E_e_AdExp, I_syn_i_E_L_E_e_AdExp, g_e_E_L_E_e_AdExp, g_i_E_L_E_e_AdExp = AdExp(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_new_b, E_i_b, w_e_AdExp_b, w_i_AdExp_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_gap_b, V_thresh_b, V_reset_gap_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, rate_window_b, membrane_noise_b)            time_V_thresh_E_e_AdExp, V_m_V_thresh_E_e_AdExp, spike_times_post_V_thresh_E_e_AdExp, rate_estimate_post_V_thresh_E_e_AdExp, I_syn_e_V_thresh_E_e_AdExp, I_syn_i_V_thresh_E_e_AdExp, g_e_V_thresh_E_e_AdExp, g_i_V_thresh_E_e_AdExp = AdExp(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_new_b, E_i_b, w_e_AdExp_b, w_i_AdExp_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_b, V_thresh_gap_b, V_reset_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, rate_window_b, membrane_noise_b)                        # run full AdExp analysis with E_e + 100 mV            r_post_E_L_E_e_AdExp, E_tot_E_L_E_e_AdExp, CV_V_m_E_L_E_e_AdExp, tuning_curve_E_L_E_e_AdExp, OSI_E_L_E_e_AdExp, OSI_per_energy_E_L_E_e_AdExp, CV_ISI_tuning_curve_E_L_E_e_AdExp, CV_ISI_tuning_curve_per_energy_E_L_E_e_AdExp, MI_tuning_curve_E_L_E_e_AdExp, MI_tuning_curve_per_energy_E_L_E_e_AdExp, MICE_tuning_curve_E_L_E_e_AdExp, MICE_tuning_curve_per_energy_E_L_E_e_AdExp, CV_ISI_E_L_E_e_AdExp, CV_ISI_per_energy_E_L_E_e_AdExp, MI_E_L_E_e_AdExp, MI_per_energy_E_L_E_e_AdExp, TE_E_L_E_e_AdExp, TE_per_energy_E_L_E_e_AdExp, MICE_E_L_E_e_AdExp, MICE_per_energy_E_L_E_e_AdExp, TECE_E_L_E_e_AdExp, TECE_per_energy_E_L_E_e_AdExp, E_vec_E_L_E_e_AdExp = af.complete_analysis(spike_times_post_E_L_E_e_AdExp, V_m_E_L_E_e_AdExp, T, R_m, C_m, E_L_gap, I_syn_e_E_L_E_e_AdExp, V_thresh, spike_times_e, w_e_AdExp, N_e_noise)            r_post_V_thresh_E_e_AdExp, E_tot_V_thresh_E_e_AdExp, CV_V_m_V_thresh_E_e_AdExp, tuning_curve_V_thresh_E_e_AdExp, OSI_V_thresh_E_e_AdExp, OSI_per_energy_V_thresh_E_e_AdExp, CV_ISI_tuning_curve_V_thresh_E_e_AdExp, CV_ISI_tuning_curve_per_energy_V_thresh_E_e_AdExp, MI_tuning_curve_V_thresh_E_e_AdExp, MI_tuning_curve_per_energy_V_thresh_E_e_AdExp, MICE_tuning_curve_V_thresh_E_e_AdExp, MICE_tuning_curve_per_energy_V_thresh_E_e_AdExp, CV_ISI_V_thresh_E_e_AdExp, CV_ISI_per_energy_V_thresh_E_e_AdExp, MI_V_thresh_E_e_AdExp, MI_per_energy_V_thresh_E_e_AdExp, TE_V_thresh_E_e_AdExp, TE_per_energy_V_thresh_E_e_AdExp, MICE_V_thresh_E_e_AdExp, MICE_per_energy_V_thresh_E_e_AdExp, TECE_V_thresh_E_e_AdExp, TECE_per_energy_V_thresh_E_e_AdExp, E_vec_V_thresh_E_e_AdExp = af.complete_analysis(spike_times_post_V_thresh_E_e_AdExp, V_m_V_thresh_E_e_AdExp, T, R_m, C_m, E_L, I_syn_e_V_thresh_E_e_AdExp, V_thresh_gap, spike_times_e, w_e_AdExp, N_e_noise)            # simulate AdExp with E_i - 100 mV            E_i_new = E_i - 10            E_i_new_b = E_i_b - 10*mV            time_E_L_E_i_AdExp, V_m_E_L_E_i_AdExp, spike_times_post_E_L_E_i_AdExp, rate_estimate_post_E_L_E_i_AdExp, I_syn_e_E_L_E_i_AdExp, I_syn_i_E_L_E_i_AdExp, g_e_E_L_E_i_AdExp, g_i_E_L_E_i_AdExp = AdExp(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_new_b, w_e_AdExp_b, w_i_AdExp_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_gap_b, V_thresh_b, V_reset_gap_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, rate_window_b, membrane_noise_b)            time_V_thresh_E_i_AdExp, V_m_V_thresh_E_i_AdExp, spike_times_post_V_thresh_E_i_AdExp, rate_estimate_post_V_thresh_E_i_AdExp, I_syn_e_V_thresh_E_i_AdExp, I_syn_i_V_thresh_E_i_AdExp, g_e_V_thresh_E_i_AdExp, g_i_V_thresh_E_i_AdExp = AdExp(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_new_b, w_e_AdExp_b, w_i_AdExp_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_b, V_thresh_gap_b, V_reset_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, rate_window_b, membrane_noise_b)                          # run full AdExp analysis with E_i - 100 mV            r_post_E_L_E_i_AdExp, E_tot_E_L_E_i_AdExp, CV_V_m_E_L_E_i_AdExp, tuning_curve_E_L_E_i_AdExp, OSI_E_L_E_i_AdExp, OSI_per_energy_E_L_E_i_AdExp, CV_ISI_tuning_curve_E_L_E_i_AdExp, CV_ISI_tuning_curve_per_energy_E_L_E_i_AdExp, MI_tuning_curve_E_L_E_i_AdExp, MI_tuning_curve_per_energy_E_L_E_i_AdExp, MICE_tuning_curve_E_L_E_i_AdExp, MICE_tuning_curve_per_energy_E_L_E_i_AdExp, CV_ISI_E_L_E_i_AdExp, CV_ISI_per_energy_E_L_E_i_AdExp, MI_E_L_E_i_AdExp, MI_per_energy_E_L_E_i_AdExp, TE_E_L_E_i_AdExp, TE_per_energy_E_L_E_i_AdExp, MICE_E_L_E_i_AdExp, MICE_per_energy_E_L_E_i_AdExp, TECE_E_L_E_i_AdExp, TECE_per_energy_E_L_E_i_AdExp, E_vec_E_L_E_i_AdExp = af.complete_analysis(spike_times_post_E_L_E_i_AdExp, V_m_E_L_E_i_AdExp, T, R_m, C_m, E_L_gap, I_syn_e_E_L_E_i_AdExp, V_thresh, spike_times_e, w_e_AdExp, N_e_noise)            r_post_V_thresh_E_i_AdExp, E_tot_V_thresh_E_i_AdExp, CV_V_m_V_thresh_E_i_AdExp, tuning_curve_V_thresh_E_i_AdExp, OSI_V_thresh_E_i_AdExp, OSI_per_energy_V_thresh_E_i_AdExp, CV_ISI_tuning_curve_V_thresh_E_i_AdExp, CV_ISI_tuning_curve_per_energy_V_thresh_E_i_AdExp, MI_tuning_curve_V_thresh_E_i_AdExp, MI_tuning_curve_per_energy_V_thresh_E_i_AdExp, MICE_tuning_curve_V_thresh_E_i_AdExp, MICE_tuning_curve_per_energy_V_thresh_E_i_AdExp, CV_ISI_V_thresh_E_i_AdExp, CV_ISI_per_energy_V_thresh_E_i_AdExp, MI_V_thresh_E_i_AdExp, MI_per_energy_V_thresh_E_i_AdExp, TE_V_thresh_E_i_AdExp, TE_per_energy_V_thresh_E_i_AdExp, MICE_V_thresh_E_i_AdExp, MICE_per_energy_V_thresh_E_i_AdExp, TECE_V_thresh_E_i_AdExp, TECE_per_energy_V_thresh_E_i_AdExp, E_vec_V_thresh_E_i_AdExp = af.complete_analysis(spike_times_post_V_thresh_E_i_AdExp, V_m_V_thresh_E_i_AdExp, T, R_m, C_m, E_L, I_syn_e_V_thresh_E_i_AdExp, V_thresh_gap, spike_times_e, w_e_AdExp, N_e_noise)                        # save E_L results in AdExp dictionary             results_E_L_AdExp = {                'V_m': [np.mean(V_m_E_L_AdExp), np.mean(V_m_E_L_E_e_AdExp), np.mean(V_m_E_L_E_i_AdExp)],                'I_syn_e': [np.mean(I_syn_e_E_L_AdExp), np.mean(I_syn_e_E_L_E_e_AdExp), np.mean(I_syn_e_E_L_E_i_AdExp)],                'I_syn_i': [np.mean(I_syn_i_E_L_AdExp), np.mean(I_syn_i_E_L_E_e_AdExp), np.mean(I_syn_i_E_L_E_i_AdExp)],                'spike_times_post': [spike_times_post_E_L_AdExp, spike_times_post_E_L_E_e_AdExp, spike_times_post_E_L_E_i_AdExp],                'r_post': [r_post_E_L_AdExp, r_post_E_L_E_e_AdExp, r_post_E_L_E_i_AdExp],                'E_tot': [E_tot_E_L_AdExp, E_tot_E_L_E_e_AdExp, E_tot_E_L_E_i_AdExp],                'tuning_curve': [tuning_curve_E_L_AdExp, tuning_curve_E_L_E_e_AdExp, tuning_curve_E_L_E_i_AdExp],                'CV_V_m': [CV_V_m_E_L_AdExp, CV_V_m_E_L_E_e_AdExp, CV_V_m_E_L_E_i_AdExp],                'OSI': [OSI_E_L_AdExp, OSI_E_L_E_e_AdExp, OSI_E_L_E_i_AdExp],                'OSI_per_energy': [OSI_per_energy_E_L_AdExp, OSI_per_energy_E_L_E_e_AdExp, OSI_per_energy_E_L_E_i_AdExp],                'CV_ISI_tuning_curve': [CV_ISI_tuning_curve_E_L_AdExp, CV_ISI_tuning_curve_E_L_E_e_AdExp, CV_ISI_tuning_curve_E_L_E_i_AdExp],                'CV_ISI_tuning_curve_per_energy': [CV_ISI_tuning_curve_per_energy_E_L_AdExp, CV_ISI_tuning_curve_per_energy_E_L_E_e_AdExp, CV_ISI_tuning_curve_per_energy_E_L_E_i_AdExp],                'MI_tuning_curve': [MI_tuning_curve_E_L_AdExp, MI_tuning_curve_E_L_E_e_AdExp, MI_tuning_curve_E_L_E_i_AdExp],                'MI_tuning_curve_per_energy': [MI_tuning_curve_per_energy_E_L_AdExp, MI_tuning_curve_per_energy_E_L_E_e_AdExp, MI_tuning_curve_per_energy_E_L_E_i_AdExp],                'MICE_tuning_curve': [MICE_tuning_curve_E_L_AdExp, MICE_tuning_curve_E_L_E_e_AdExp, MICE_tuning_curve_E_L_E_i_AdExp],                'MICE_tuning_curve_per_energy': [MICE_tuning_curve_per_energy_E_L_AdExp, MICE_tuning_curve_per_energy_E_L_E_e_AdExp, MICE_tuning_curve_per_energy_E_L_E_i_AdExp],                'CV_ISI': [CV_ISI_E_L_AdExp, CV_ISI_E_L_E_e_AdExp, CV_ISI_E_L_E_i_AdExp],                'CV_ISI_per_energy': [CV_ISI_per_energy_E_L_AdExp, CV_ISI_per_energy_E_L_E_e_AdExp, CV_ISI_per_energy_E_L_E_i_AdExp],                'MI': [MI_E_L_AdExp, MI_E_L_E_e_AdExp, MI_E_L_E_i_AdExp],                'MI_per_energy': [MI_per_energy_E_L_AdExp, MI_per_energy_E_L_E_e_AdExp, MI_per_energy_E_L_E_i_AdExp],                'TE': [TE_E_L_AdExp, TE_E_L_E_e_AdExp, TE_E_L_E_i_AdExp],                'TE_per_energy': [TE_per_energy_E_L_AdExp, TE_per_energy_E_L_E_e_AdExp, TE_per_energy_E_L_E_i_AdExp],                'MICE': [MICE_E_L_AdExp, MICE_E_L_E_e_AdExp, MICE_E_L_E_i_AdExp],                'MICE_per_energy': [MICE_per_energy_E_L_AdExp, MICE_per_energy_E_L_E_e_AdExp, MICE_per_energy_E_L_E_i_AdExp],                'TECE': [TECE_E_L_AdExp, TECE_E_L_E_e_AdExp, TECE_E_L_E_i_AdExp],                'TECE_per_energy': [TECE_per_energy_E_L_AdExp, TECE_per_energy_E_L_E_e_AdExp, TECE_per_energy_E_L_E_i_AdExp]}                        results_V_thresh_AdExp = {                'V_m': [np.mean(V_m_V_thresh_AdExp), np.mean(V_m_V_thresh_E_e_AdExp), np.mean(V_m_V_thresh_E_i_AdExp)],                'I_syn_e': [np.mean(I_syn_e_V_thresh_AdExp), np.mean(I_syn_e_V_thresh_E_e_AdExp), np.mean(I_syn_e_V_thresh_E_i_AdExp)],                'I_syn_i': [np.mean(I_syn_i_V_thresh_AdExp), np.mean(I_syn_i_V_thresh_E_e_AdExp), np.mean(I_syn_i_V_thresh_E_i_AdExp)],                'spike_times_post': [spike_times_post_V_thresh_AdExp, spike_times_post_V_thresh_E_e_AdExp, spike_times_post_V_thresh_E_i_AdExp],                'r_post': [r_post_V_thresh_AdExp, r_post_V_thresh_E_e_AdExp, r_post_V_thresh_E_i_AdExp],                'E_tot': [E_tot_V_thresh_AdExp, E_tot_V_thresh_E_e_AdExp, E_tot_V_thresh_E_i_AdExp],                'tuning_curve': [tuning_curve_V_thresh_AdExp, tuning_curve_V_thresh_E_e_AdExp, tuning_curve_V_thresh_E_i_AdExp],                'CV_V_m': [CV_V_m_V_thresh_AdExp, CV_V_m_V_thresh_E_e_AdExp, CV_V_m_V_thresh_E_i_AdExp],                'OSI': [OSI_V_thresh_AdExp, OSI_V_thresh_E_e_AdExp, OSI_V_thresh_E_i_AdExp],                'OSI_per_energy': [OSI_per_energy_V_thresh_AdExp, OSI_per_energy_V_thresh_E_e_AdExp, OSI_per_energy_V_thresh_E_i_AdExp],                'CV_ISI_tuning_curve': [CV_ISI_tuning_curve_V_thresh_AdExp, CV_ISI_tuning_curve_V_thresh_E_e_AdExp, CV_ISI_tuning_curve_V_thresh_E_i_AdExp],                'CV_ISI_tuning_curve_per_energy': [CV_ISI_tuning_curve_per_energy_V_thresh_AdExp, CV_ISI_tuning_curve_per_energy_V_thresh_E_e_AdExp, CV_ISI_tuning_curve_per_energy_V_thresh_E_i_AdExp],                'MI_tuning_curve': [MI_tuning_curve_V_thresh_AdExp, MI_tuning_curve_V_thresh_E_e_AdExp, MI_tuning_curve_V_thresh_E_i_AdExp],                'MI_tuning_curve_per_energy': [MI_tuning_curve_per_energy_V_thresh_AdExp, MI_tuning_curve_per_energy_V_thresh_E_e_AdExp, MI_tuning_curve_per_energy_V_thresh_E_i_AdExp],                'MICE_tuning_curve': [MICE_tuning_curve_V_thresh_AdExp, MICE_tuning_curve_V_thresh_E_e_AdExp, MICE_tuning_curve_V_thresh_E_i_AdExp],                'MICE_tuning_curve_per_energy': [MICE_tuning_curve_per_energy_V_thresh_AdExp, MICE_tuning_curve_per_energy_V_thresh_E_e_AdExp, MICE_tuning_curve_per_energy_V_thresh_E_i_AdExp],                'CV_ISI': [CV_ISI_V_thresh_AdExp, CV_ISI_V_thresh_E_e_AdExp, CV_ISI_V_thresh_E_i_AdExp],                'CV_ISI_per_energy': [CV_ISI_per_energy_V_thresh_AdExp, CV_ISI_per_energy_V_thresh_E_e_AdExp, CV_ISI_per_energy_V_thresh_E_i_AdExp],                'MI': [MI_V_thresh_AdExp, MI_V_thresh_E_e_AdExp, MI_V_thresh_E_i_AdExp],                'MI_per_energy': [MI_per_energy_V_thresh_AdExp, MI_per_energy_V_thresh_E_e_AdExp, MI_per_energy_V_thresh_E_i_AdExp],                'TE': [TE_V_thresh_AdExp, TE_V_thresh_E_e_AdExp, TE_V_thresh_E_i_AdExp],                'TE_per_energy': [TE_per_energy_V_thresh_AdExp, TE_per_energy_V_thresh_E_e_AdExp, TE_per_energy_V_thresh_E_i_AdExp],                'MICE': [MICE_V_thresh_AdExp, MICE_V_thresh_E_e_AdExp, MICE_V_thresh_E_i_AdExp],                'MICE_per_energy': [MICE_per_energy_V_thresh_AdExp, MICE_per_energy_V_thresh_E_e_AdExp, MICE_per_energy_V_thresh_E_i_AdExp],                'TECE': [TECE_V_thresh_AdExp, TECE_V_thresh_E_e_AdExp, TECE_V_thresh_E_i_AdExp],                'TECE_per_energy': [TECE_per_energy_V_thresh_AdExp, TECE_per_energy_V_thresh_E_e_AdExp, TECE_per_energy_V_thresh_E_i_AdExp]}                        # append values to results dictionary            for key, value in results_E_L_AdExp.items():                results_single_run_E_L_AdExp[key].append(value)                        for key, value in results_V_thresh_AdExp.items():                results_single_run_V_thresh_AdExp[key].append(value)        # add V_gap_absolute_list to results dictionary    results_single_run_E_L_LIF['V_gap_absolute_list'] = V_gap_absolute_list    results_single_run_V_thresh_LIF['V_gap_absolute_list'] = V_gap_absolute_list    results_single_run_E_L_AdExp['V_gap_absolute_list'] = V_gap_absolute_list    results_single_run_V_thresh_AdExp['V_gap_absolute_list'] = V_gap_absolute_list        return results_single_run_E_L_LIF, results_single_run_V_thresh_LIF, results_single_run_E_L_AdExp, results_single_run_V_thresh_AdExp########################################### V_gap_constant runs ####################################################################################def single_V_gap_constant_run(V_rests, Delta_V_thresh, model_mode, membrane_noise=0.0):    # run a single moving constant V_gap simulation        # input    # V_rests is an array of leak potentials/resting potentials    # Delta_V_thresh is the distance to keep constant between  V_rest and V_threshold    # model_mode is a list of strings or string & decides which model is used for simulation    # membrane_noise is the standard deviation of the membrane noise in mV/ms    # output     # results_single_run_V_gap_LIF, results_single_run_V_gap_AdExp are the results dictionaries    # initialize dictionaries to save results    results_single_run_V_gap_LIF, results_single_run_V_gap_AdExp = empty_results_dictionary(), empty_results_dictionary()        # load parameter values    # define synaptic input    N_syn, N_e, N_e_signal_ratio, N_i, rate_background_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, mu_weight_e, sigma_weight_e, mu_weight_i, sigma_weight_i = sif.synaptic_parameters(synaptic_scaling_mode='multiplicative')        # orientation variation input    w_e_0, w_i_0, spike_times_e, spike_times_i, r_e, r_i, t_stim, T, N_e_signal, N_e_noise = sif.orientation_variation_input(N_e, N_i, N_e_signal_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, rate_background_ratio, mu_weight_e, sigma_weight_e, mu_weight_i, sigma_weight_i)        # load CTR parameter values    C_m, E_L, R_m, g_L, V_thresh, V_reset, rate_window, E_e, E_i, tau_e, tau_i, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise = sim_parameters(parameter_mode='CTR', membrane_noise=membrane_noise)        # scale CTR synaptic input    w_scale_CTR = 100    w_e = w_e_0 * 5 * w_scale_CTR * 4 # low E/I balance: 4/1    w_i = w_i_0 * 5 * w_scale_CTR * 1 # low E/I balance: 4/1    # save V_gap_absolute values    V_rests_list = []        # iterate through all V_rests    for V_rest in V_rests:        E_L_gap = V_rest        V_reset_gap = V_rest        V_thresh_gap = V_rest + Delta_V_thresh        V_rests_list.append(V_rest)                # simulate LIF if given            if 'LIF' in model_mode:            # scale LIF synaptic input            w_e_LIF = w_e            w_i_LIF = w_i                        # translate CTR to Brian-readable values            T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_LIF_b, w_i_LIF_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_gap_b, V_thresh_gap_b, V_reset_gap_b, rate_window_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, membrane_noise_b = parameters_brian(T, N_e, N_i, spike_times_e, spike_times_i, E_e, E_i, w_e_LIF, w_i_LIF, tau_e, tau_i, C_m, g_L, E_L_gap, V_thresh_gap, V_reset_gap, rate_window, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise)                         # simulate LIF            time_V_gap_LIF, V_m_V_gap_LIF, spike_times_post_V_gap_LIF, rate_estimate_post_V_gap_LIF, I_syn_e_V_gap_LIF, I_syn_i_V_gap_LIF, g_e_V_gap_LIF, g_i_V_gap_LIF = LIF(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_LIF_b, w_i_LIF_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_gap_b, V_thresh_gap_b, V_reset_gap_b, rate_window_b, membrane_noise_b)                        # run full LIF analysis            r_post_V_gap_LIF, E_tot_V_gap_LIF, CV_V_m_V_gap_LIF, tuning_curve_V_gap_LIF, OSI_V_gap_LIF, OSI_per_energy_V_gap_LIF, CV_ISI_tuning_curve_V_gap_LIF, CV_ISI_tuning_curve_per_energy_V_gap_LIF, MI_tuning_curve_V_gap_LIF, MI_tuning_curve_per_energy_V_gap_LIF, MICE_tuning_curve_V_gap_LIF, MICE_tuning_curve_per_energy_V_gap_LIF, CV_ISI_V_gap_LIF, CV_ISI_per_energy_V_gap_LIF, MI_V_gap_LIF, MI_per_energy_V_gap_LIF, TE_V_gap_LIF, TE_per_energy_V_gap_LIF, MICE_V_gap_LIF, MICE_per_energy_V_gap_LIF, TECE_V_gap_LIF, TECE_per_energy_V_gap_LIF, E_vec_V_gap_LIF = af.complete_analysis(spike_times_post_V_gap_LIF, V_m_V_gap_LIF, T, R_m, C_m, E_L_gap, I_syn_e_V_gap_LIF, V_thresh_gap, spike_times_e, w_e_LIF, N_e_noise)            # save V_gap results in LIF dictionary             results_V_gap_LIF = save_results_dictionary(V_m_V_gap_LIF, I_syn_e_V_gap_LIF, I_syn_i_V_gap_LIF, spike_times_post_V_gap_LIF, r_post_V_gap_LIF, E_tot_V_gap_LIF, CV_V_m_V_gap_LIF, tuning_curve_V_gap_LIF, OSI_V_gap_LIF, OSI_per_energy_V_gap_LIF, CV_ISI_tuning_curve_V_gap_LIF, CV_ISI_tuning_curve_per_energy_V_gap_LIF, MI_tuning_curve_V_gap_LIF, MI_tuning_curve_per_energy_V_gap_LIF, MICE_tuning_curve_V_gap_LIF, MICE_tuning_curve_per_energy_V_gap_LIF, CV_ISI_V_gap_LIF, CV_ISI_per_energy_V_gap_LIF, MI_V_gap_LIF, MI_per_energy_V_gap_LIF, TE_V_gap_LIF, TE_per_energy_V_gap_LIF, MICE_V_gap_LIF, MICE_per_energy_V_gap_LIF, TECE_V_gap_LIF, TECE_per_energy_V_gap_LIF)                        # append values to results dictionary            for key, value in results_V_gap_LIF.items():                results_single_run_V_gap_LIF[key].append(value)                    # simulate AdExp if given          if 'AdExp' in model_mode:                               # scale synaptic input            weight_factor_LIF_to_AdExp = 1.0 #1.5            w_e_AdExp = w_e * weight_factor_LIF_to_AdExp            w_i_AdExp = w_i * weight_factor_LIF_to_AdExp                        # translate CTR to Brian-readable values            T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_AdExp_b, w_i_AdExp_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_gap_b, V_thresh_gap_b, V_reset_gap_b, rate_window_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, membrane_noise_b = parameters_brian(T, N_e, N_i, spike_times_e, spike_times_i, E_e, E_i, w_e_AdExp, w_i_AdExp, tau_e, tau_i, C_m, g_L, E_L_gap, V_thresh_gap, V_reset_gap, rate_window, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise)                         # simulate AdExp            time_V_gap_AdExp, V_m_V_gap_AdExp, spike_times_post_V_gap_AdExp, rate_estimate_post_V_gap_AdExp, I_syn_e_V_gap_AdExp, I_syn_i_V_gap_AdExp, g_e_V_gap_AdExp, g_i_V_gap_AdExp = AdExp(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_AdExp_b, w_i_AdExp_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_gap_b, V_thresh_gap_b, V_reset_gap_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, rate_window_b, membrane_noise_b)                        # run full AdExp analysis            r_post_V_gap_AdExp, E_tot_V_gap_AdExp, CV_V_m_V_gap_AdExp, tuning_curve_V_gap_AdExp, OSI_V_gap_AdExp, OSI_per_energy_V_gap_AdExp, CV_ISI_tuning_curve_V_gap_AdExp, CV_ISI_tuning_curve_per_energy_V_gap_AdExp, MI_tuning_curve_V_gap_AdExp, MI_tuning_curve_per_energy_V_gap_AdExp, MICE_tuning_curve_V_gap_AdExp, MICE_tuning_curve_per_energy_V_gap_AdExp, CV_ISI_V_gap_AdExp, CV_ISI_per_energy_V_gap_AdExp, MI_V_gap_AdExp, MI_per_energy_V_gap_AdExp, TE_V_gap_AdExp, TE_per_energy_V_gap_AdExp, MICE_V_gap_AdExp, MICE_per_energy_V_gap_AdExp, TECE_V_gap_AdExp, TECE_per_energy_V_gap_AdExp, E_vec_V_gap_AdExp = af.complete_analysis(spike_times_post_V_gap_AdExp, V_m_V_gap_AdExp, T, R_m, C_m, E_L_gap, I_syn_e_V_gap_AdExp, V_thresh_gap, spike_times_e, w_e_AdExp, N_e_noise)            # save V_gap results in AdExp dictionary             results_V_gap_AdExp = save_results_dictionary(V_m_V_gap_AdExp, I_syn_e_V_gap_AdExp, I_syn_i_V_gap_AdExp, r_post_V_gap_AdExp, E_tot_V_gap_AdExp, CV_V_m_V_gap_AdExp, tuning_curve_V_gap_AdExp, OSI_V_gap_AdExp, OSI_per_energy_V_gap_AdExp, CV_ISI_tuning_curve_V_gap_AdExp, CV_ISI_tuning_curve_per_energy_V_gap_AdExp, MI_tuning_curve_V_gap_AdExp, MI_tuning_curve_per_energy_V_gap_AdExp, MICE_tuning_curve_V_gap_AdExp, MICE_tuning_curve_per_energy_V_gap_AdExp, CV_ISI_V_gap_AdExp, CV_ISI_per_energy_V_gap_AdExp, MI_V_gap_AdExp, MI_per_energy_V_gap_AdExp, TE_V_gap_AdExp, TE_per_energy_V_gap_AdExp, MICE_V_gap_AdExp, MICE_per_energy_V_gap_AdExp, TECE_V_gap_AdExp, TECE_per_energy_V_gap_AdExp)                        # append values to results dictionary            for key, value in results_V_gap_AdExp.items():                results_single_run_V_gap_AdExp[key].append(value)        # add V_gap_absolute_list to results dictionary    results_single_run_V_gap_LIF['V_rests_list'] = V_rests_list    results_single_run_V_gap_AdExp['V_rests_list'] = V_rests_list        return results_single_run_V_gap_LIF, results_single_run_V_gap_AdExpdef multiple_V_gap_constant_runs(number_V_gap_runs, V_rests, Delta_V_thresh, model_mode, membrane_noise=0.0, savename=None):     # run multiple moving constant V_gap simulation        # input    # number_V_gap_runs is the number of V_gap runs to perform    # V_rests is an array of leak potentials/resting potentials    # Delta_V_thresh is the distance to keep constant between  V_rest and V_threshold    # model_mode is a list of strings or string & decides which model is used for simulation    # membrane_noise is the standard deviation of the membrane noise in mV/ms    # output     # results_multiple_runs_V_gap_LIF, results_multiple_runs_V_gap_AdExp are the results dictionaries    # initialize dictionaries to save results    results_multiple_runs_V_gap_LIF, results_multiple_runs_V_gap_AdExp = empty_results_dictionary(), empty_results_dictionary()    results_multiple_runs_V_gap_LIF['V_rests_list'] = []    results_multiple_runs_V_gap_AdExp['V_rests_list'] = []        # simulate number_V_gap_runs times and save results in results dictionary    for run_number in range(number_V_gap_runs):        results_single_run_V_gap_LIF, results_single_run_V_gap_AdExp = single_V_gap_constant_run(V_rests, Delta_V_thresh, model_mode=model_mode, membrane_noise=membrane_noise)                for key, value in results_single_run_V_gap_LIF.items():            results_multiple_runs_V_gap_LIF[key].append(value)                for key, value in results_single_run_V_gap_AdExp.items():            results_multiple_runs_V_gap_AdExp[key].append(value)    # save results if savename is provided    if savename is not None:        with open(f'{savename}_results_multiple_V_gap_constant_runs_LIF.pkl', 'wb') as f:            pickle.dump(results_multiple_runs_V_gap_LIF, f)        with open(f'{savename}_results_multiple_V_gap_constant_runs_AdExp.pkl', 'wb') as f:            pickle.dump(results_multiple_runs_V_gap_AdExp, f)                return results_multiple_runs_V_gap_LIF, results_multiple_runs_V_gap_AdExpdef single_CTR_FR_V_gap_constant_run(V_rests, Delta_V_thresh, model_mode, w_scale=95, membrane_noise=0.0):    # run a single moving constant V_gap simulation for CTR & FR        # input    # V_rests is an array of leak potentials/resting potentials    # Delta_V_thresh is a list of CTR & FR distances to keep constant between  V_rest and V_threshold    # model_mode is a list of strings or string & decides which model is used for simulation    # w_scale is the synaptic scaling factor    # membrane_noise is the standard deviation of the membrane noise in mV/ms    # output     # results_single_run_V_gap_CTR_LIF, results_single_run_V_gap_FR_LIF, results_single_run_V_gap_CTR_AdExp, results_single_run_V_gap_FR_AdExp are the results dictionaries    # initialize dictionaries to save results    results_single_run_V_gap_CTR_LIF, results_single_run_V_gap_FR_LIF, results_single_run_V_gap_CTR_AdExp, results_single_run_V_gap_FR_AdExp = empty_results_dictionary(), empty_results_dictionary(), empty_results_dictionary(), empty_results_dictionary()        # load parameter values    # define synaptic input    N_syn, N_e, N_e_signal_ratio, N_i, rate_background_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, mu_weight_e, sigma_weight_e, mu_weight_i, sigma_weight_i = sif.synaptic_parameters(synaptic_scaling_mode='multiplicative')        # orientation variation input    w_e_0, w_i_0, spike_times_e, spike_times_i, r_e, r_i, t_stim, T, N_e_signal, N_e_noise = sif.orientation_variation_input(N_e, N_i, N_e_signal_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, rate_background_ratio, mu_weight_e, sigma_weight_e, mu_weight_i, sigma_weight_i)     # load CTR parameter values    C_m, E_L_CTR, R_m_CTR, g_L_CTR, V_thresh, V_reset_CTR, rate_window, E_e, E_i, tau_e, tau_i, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise = sim_parameters(parameter_mode='CTR', membrane_noise=membrane_noise)    # load FR parameter values    C_m, E_L_FR, R_m_FR, g_L_FR, V_thresh, V_reset_FR, rate_window, E_e, E_i, tau_e, tau_i, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise = sim_parameters(parameter_mode='FR', membrane_noise=membrane_noise)    # scale CTR synaptic input    w_scale_CTR = w_scale    w_e_CTR = w_e_0 * 5 * w_scale_CTR * 4 # low E/I balance: 4/1    w_i_CTR = w_i_0 * 5 * w_scale_CTR * 1 # low E/I balance: 4/1    # scale FR synaptic input    w_scale_FR = w_scale_CTR*0.7 # 0.65    w_e_FR = w_e_0 * 5 * w_scale_FR * 4 # low E/I balance: 4/1    w_i_FR = w_i_0 * 5 * w_scale_FR * 1 # low E/I balance: 4/1    # save V_gap_absolute values    V_rests_list = []        # get CTR & FR Delta_V_thresh    Delta_V_thresh_CTR = Delta_V_thresh[0]    Delta_V_thresh_FR = Delta_V_thresh[1]        # iterate through all V_rests    for V_rest in V_rests:        E_L_gap = V_rest        V_reset_gap = V_rest        V_thresh_CTR_gap = V_rest + Delta_V_thresh_CTR        V_thresh_FR_gap = V_rest + Delta_V_thresh_FR        V_rests_list.append(V_rest)                # simulate LIF if given            if 'LIF' in model_mode:            # scale LIF synaptic input            w_e_CTR_LIF = w_e_CTR            w_i_CTR_LIF = w_i_CTR                        w_e_FR_LIF = w_e_FR            w_i_FR_LIF = w_i_FR                        # translate CTR to Brian-readable values            T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_CTR_LIF_b, w_i_CTR_LIF_b, tau_e_b, tau_i_b, C_m_b, g_L_CTR_b, E_L_gap_b, V_thresh_CTR_gap_b, V_reset_gap_b, rate_window_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, membrane_noise_b = parameters_brian(T, N_e, N_i, spike_times_e, spike_times_i, E_e, E_i, w_e_CTR_LIF, w_i_CTR_LIF, tau_e, tau_i, C_m, g_L_CTR, E_L_gap, V_thresh_CTR_gap, V_reset_gap, rate_window, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise)             # translate FR to Brian-readable values            T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_FR_LIF_b, w_i_FR_LIF_b, tau_e_b, tau_i_b, C_m_b, g_L_FR_b, E_L_gap_b, V_thresh_FR_gap_b, V_reset_gap_b, rate_window_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, membrane_noise_b = parameters_brian(T, N_e, N_i, spike_times_e, spike_times_i, E_e, E_i, w_e_FR_LIF, w_i_FR_LIF, tau_e, tau_i, C_m, g_L_FR, E_L_gap, V_thresh_FR_gap, V_reset_gap, rate_window, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise)             # simulate CTR LIF            time_V_gap_CTR_LIF, V_m_V_gap_CTR_LIF, spike_times_post_V_gap_CTR_LIF, rate_estimate_post_V_gap_CTR_LIF, I_syn_e_V_gap_CTR_LIF, I_syn_i_V_gap_CTR_LIF, g_e_V_gap_CTR_LIF, g_i_V_gap_CTR_LIF = LIF(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_CTR_LIF_b, w_i_CTR_LIF_b, tau_e_b, tau_i_b, C_m_b, g_L_CTR_b, E_L_gap_b, V_thresh_CTR_gap_b, V_reset_gap_b, rate_window_b, membrane_noise_b)            # simulate FR LIF            time_V_gap_FR_LIF, V_m_V_gap_FR_LIF, spike_times_post_V_gap_FR_LIF, rate_estimate_post_V_gap_FR_LIF, I_syn_e_V_gap_FR_LIF, I_syn_i_V_gap_FR_LIF, g_e_V_gap_FR_LIF, g_i_V_gap_FR_LIF = LIF(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_FR_LIF_b, w_e_FR_LIF_b, tau_e_b, tau_i_b, C_m_b, g_L_FR_b, E_L_gap_b, V_thresh_FR_gap_b, V_reset_gap_b, rate_window_b, membrane_noise_b)                        # run full CTR LIF analysis            r_post_V_gap_CTR_LIF, E_tot_V_gap_CTR_LIF, CV_V_m_V_gap_CTR_LIF, tuning_curve_V_gap_CTR_LIF, OSI_V_gap_CTR_LIF, OSI_per_energy_V_gap_CTR_LIF, CV_ISI_tuning_curve_V_gap_CTR_LIF, CV_ISI_tuning_curve_per_energy_V_gap_CTR_LIF, MI_tuning_curve_V_gap_CTR_LIF, MI_tuning_curve_per_energy_V_gap_CTR_LIF, MICE_tuning_curve_V_gap_CTR_LIF, MICE_tuning_curve_per_energy_V_gap_CTR_LIF, CV_ISI_V_gap_CTR_LIF, CV_ISI_per_energy_V_gap_CTR_LIF, MI_V_gap_CTR_LIF, MI_per_energy_V_gap_CTR_LIF, TE_V_gap_CTR_LIF, TE_per_energy_V_gap_CTR_LIF, MICE_V_gap_CTR_LIF, MICE_per_energy_V_gap_CTR_LIF, TECE_V_gap_CTR_LIF, TECE_per_energy_V_gap_CTR_LIF, E_vec_V_gap_CTR_LIF = af.complete_analysis(spike_times_post_V_gap_CTR_LIF, V_m_V_gap_CTR_LIF, T, R_m_CTR, C_m, E_L_gap, I_syn_e_V_gap_CTR_LIF, V_thresh_CTR_gap, spike_times_e, w_e_CTR_LIF, N_e_noise)            # run full FR LIF analysis            r_post_V_gap_FR_LIF, E_tot_V_gap_FR_LIF, CV_V_m_V_gap_FR_LIF, tuning_curve_V_gap_FR_LIF, OSI_V_gap_FR_LIF, OSI_per_energy_V_gap_FR_LIF, CV_ISI_tuning_curve_V_gap_FR_LIF, CV_ISI_tuning_curve_per_energy_V_gap_FR_LIF, MI_tuning_curve_V_gap_FR_LIF, MI_tuning_curve_per_energy_V_gap_FR_LIF, MICE_tuning_curve_V_gap_FR_LIF, MICE_tuning_curve_per_energy_V_gap_FR_LIF, CV_ISI_V_gap_FR_LIF, CV_ISI_per_energy_V_gap_FR_LIF, MI_V_gap_FR_LIF, MI_per_energy_V_gap_FR_LIF, TE_V_gap_FR_LIF, TE_per_energy_V_gap_FR_LIF, MICE_V_gap_FR_LIF, MICE_per_energy_V_gap_FR_LIF, TECE_V_gap_FR_LIF, TECE_per_energy_V_gap_FR_LIF, E_vec_V_gap_FR_LIF = af.complete_analysis(spike_times_post_V_gap_FR_LIF, V_m_V_gap_FR_LIF, T, R_m_FR, C_m, E_L_gap, I_syn_e_V_gap_FR_LIF, V_thresh_FR_gap, spike_times_e, w_e_FR_LIF, N_e_noise)                        # save V_gap CTR results in LIF dictionary             results_V_gap_CTR_LIF = save_results_dictionary(V_m_V_gap_CTR_LIF, I_syn_e_V_gap_CTR_LIF, I_syn_i_V_gap_CTR_LIF, spike_times_post_V_gap_CTR_LIF, r_post_V_gap_CTR_LIF, E_tot_V_gap_CTR_LIF, CV_V_m_V_gap_CTR_LIF, tuning_curve_V_gap_CTR_LIF, OSI_V_gap_CTR_LIF, OSI_per_energy_V_gap_CTR_LIF, CV_ISI_tuning_curve_V_gap_CTR_LIF, CV_ISI_tuning_curve_per_energy_V_gap_CTR_LIF, MI_tuning_curve_V_gap_CTR_LIF, MI_tuning_curve_per_energy_V_gap_CTR_LIF, MICE_tuning_curve_V_gap_CTR_LIF, MICE_tuning_curve_per_energy_V_gap_CTR_LIF, CV_ISI_V_gap_CTR_LIF, CV_ISI_per_energy_V_gap_CTR_LIF, MI_V_gap_CTR_LIF, MI_per_energy_V_gap_CTR_LIF, TE_V_gap_CTR_LIF, TE_per_energy_V_gap_CTR_LIF, MICE_V_gap_CTR_LIF, MICE_per_energy_V_gap_CTR_LIF, TECE_V_gap_CTR_LIF, TECE_per_energy_V_gap_CTR_LIF)                        # append values to results dictionary            for key, value in results_V_gap_CTR_LIF.items():                results_single_run_V_gap_CTR_LIF[key].append(value)            # save V_gap FR results in LIF dictionary             results_V_gap_CTR_LIF = save_results_dictionary(V_m_V_gap_CTR_LIF, I_syn_e_V_gap_CTR_LIF, I_syn_i_V_gap_CTR_LIF, spike_times_post_V_gap_FR_LIF, r_post_V_gap_CTR_LIF, E_tot_V_gap_CTR_LIF, CV_V_m_V_gap_CTR_LIF, tuning_curve_V_gap_CTR_LIF, OSI_V_gap_CTR_LIF, OSI_per_energy_V_gap_CTR_LIF, CV_ISI_tuning_curve_V_gap_CTR_LIF, CV_ISI_tuning_curve_per_energy_V_gap_CTR_LIF, MI_tuning_curve_V_gap_CTR_LIF, MI_tuning_curve_per_energy_V_gap_CTR_LIF, MICE_tuning_curve_V_gap_CTR_LIF, MICE_tuning_curve_per_energy_V_gap_CTR_LIF, CV_ISI_V_gap_CTR_LIF, CV_ISI_per_energy_V_gap_CTR_LIF, MI_V_gap_CTR_LIF, MI_per_energy_V_gap_CTR_LIF, TE_V_gap_CTR_LIF, TE_per_energy_V_gap_CTR_LIF, MICE_V_gap_CTR_LIF, MICE_per_energy_V_gap_CTR_LIF, TECE_V_gap_CTR_LIF, TECE_per_energy_V_gap_CTR_LIF)                        # append values to results dictionary            for key, value in results_V_gap_CTR_LIF.items():                results_single_run_V_gap_CTR_LIF[key].append(value)                                # simulate AdExp if given          if 'AdExp' in model_mode:                               # scale synaptic input            weight_factor_LIF_to_AdExp = 1.0 #1.5            w_e_CTR_AdExp = w_e_CTR * weight_factor_LIF_to_AdExp            w_i_CTR_AdExp = w_i_CTR * weight_factor_LIF_to_AdExp                        w_e_FR_AdExp = w_e_FR * weight_factor_LIF_to_AdExp            w_i_FR_AdExp = w_i_FR * weight_factor_LIF_to_AdExp                        # translate CTR to Brian-readable values            T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_CTR_AdExp_b, w_i_CTR_AdExp_b, tau_e_b, tau_i_b, C_m_b, g_L_CTR_b, E_L_gap_b, V_thresh_CTR_gap_b, V_reset_gap_b, rate_window_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, membrane_noise_b = parameters_brian(T, N_e, N_i, spike_times_e, spike_times_i, E_e, E_i, w_e_CTR_AdExp, w_i_CTR_AdExp, tau_e, tau_i, C_m, g_L_CTR, E_L_gap, V_thresh_CTR_gap, V_reset_gap, rate_window, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise)             # translate FR to Brian-readable values            T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_FR_AdExp_b, w_i_FR_AdExp_b, tau_e_b, tau_i_b, C_m_b, g_L_FR_b, E_L_gap_b, V_thresh_FR_gap_b, V_reset_gap_b, rate_window_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, membrane_noise_b = parameters_brian(T, N_e, N_i, spike_times_e, spike_times_i, E_e, E_i, w_e_FR_AdExp, w_i_FR_AdExp, tau_e, tau_i, C_m, g_L_FR, E_L_gap, V_thresh_FR_gap, V_reset_gap, rate_window, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise)             # simulate CTR AdExp            time_V_gap_CTR_AdExp, V_m_V_gap_CTR_AdExp, spike_times_post_V_gap_CTR_AdExp, rate_estimate_post_V_gap_CTR_AdExp, I_syn_e_V_gap_CTR_AdExp, I_syn_i_V_gap_CTR_AdExp, g_e_V_gap_CTR_AdExp, g_i_V_gap_CTR_AdExp = AdExp(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_CTR_AdExp_b, w_i_CTR_AdExp_b, tau_e_b, tau_i_b, C_m_b, g_L_CTR_b, E_L_gap_b, V_thresh_CTR_gap_b, V_reset_gap_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, rate_window_b, membrane_noise_b)                        # simulate FR AdExp            time_V_gap_FR_AdExp, V_m_V_gap_FR_AdExp, spike_times_post_V_gap_FR_AdExp, rate_estimate_post_V_gap_FR_AdExp, I_syn_e_V_gap_FR_AdExp, I_syn_i_V_gap_FR_AdExp, g_e_V_gap_FR_AdExp, g_i_V_gap_FR_AdExp = AdExp(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_FR_AdExp_b, w_i_FR_AdExp_b, tau_e_b, tau_i_b, C_m_b, g_L_FR_b, E_L_gap_b, V_thresh_FR_gap_b, V_reset_gap_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, rate_window_b, membrane_noise_b)                        # run full CTR AdExp analysis            r_post_V_gap_CTR_AdExp, E_tot_V_gap_CTR_AdExp, CV_V_m_V_gap_CTR_AdExp, tuning_curve_V_gap_CTR_AdExp, OSI_V_gap_CTR_AdExp, OSI_per_energy_V_gap_CTR_AdExp, CV_ISI_tuning_curve_V_gap_CTR_AdExp, CV_ISI_tuning_curve_per_energy_V_gap_CTR_AdExp, MI_tuning_curve_V_gap_CTR_AdExp, MI_tuning_curve_per_energy_V_gap_CTR_AdExp, MICE_tuning_curve_V_gap_CTR_AdExp, MICE_tuning_curve_per_energy_V_gap_CTR_AdExp, CV_ISI_V_gap_CTR_AdExp, CV_ISI_per_energy_V_gap_CTR_AdExp, MI_V_gap_CTR_AdExp, MI_per_energy_V_gap_CTR_AdExp, TE_V_gap_CTR_AdExp, TE_per_energy_V_gap_CTR_AdExp, MICE_V_gap_CTR_AdExp, MICE_per_energy_V_gap_CTR_AdExp, TECE_V_gap_CTR_AdExp, TECE_per_energy_V_gap_CTR_AdExp, E_vec_V_gap_CTR_AdExp = af.complete_analysis(spike_times_post_V_gap_CTR_AdExp, V_m_V_gap_CTR_AdExp, T, R_m_CTR, C_m, E_L_gap, I_syn_e_V_gap_CTR_AdExp, V_thresh_CTR_gap, spike_times_e, w_e_CTR_AdExp, N_e_noise)            # run full FR AdExp analysis            r_post_V_gap_FR_AdExp, E_tot_V_gap_FR_AdExp, CV_V_m_V_gap_FR_AdExp, tuning_curve_V_gap_FR_AdExp, OSI_V_gap_FR_AdExp, OSI_per_energy_V_gap_FR_AdExp, CV_ISI_tuning_curve_V_gap_FR_AdExp, CV_ISI_tuning_curve_per_energy_V_gap_FR_AdExp, MI_tuning_curve_V_gap_FR_AdExp, MI_tuning_curve_per_energy_V_gap_FR_AdExp, MICE_tuning_curve_V_gap_FR_AdExp, MICE_tuning_curve_per_energy_V_gap_FR_AdExp, CV_ISI_V_gap_FR_AdExp, CV_ISI_per_energy_V_gap_FR_AdExp, MI_V_gap_FR_AdExp, MI_per_energy_V_gap_FR_AdExp, TE_V_gap_FR_AdExp, TE_per_energy_V_gap_FR_AdExp, MICE_V_gap_FR_AdExp, MICE_per_energy_V_gap_FR_AdExp, TECE_V_gap_FR_AdExp, TECE_per_energy_V_gap_FR_AdExp, E_vec_V_gap_FR_AdExp = af.complete_analysis(spike_times_post_V_gap_FR_AdExp, V_m_V_gap_FR_AdExp, T, R_m_FR, C_m, E_L_gap, I_syn_e_V_gap_FR_AdExp, V_thresh_FR_gap, spike_times_e, w_e_FR_AdExp, N_e_noise)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          # save V_gap CTR results in AdExp dictionary             results_V_gap_CTR_AdExp = save_results_dictionary(V_m_V_gap_CTR_AdExp, I_syn_e_V_gap_CTR_AdExp, I_syn_i_V_gap_CTR_AdExp, spike_times_post_V_gap_CTR_AdExp, r_post_V_gap_CTR_AdExp, E_tot_V_gap_CTR_AdExp, CV_V_m_V_gap_CTR_AdExp, tuning_curve_V_gap_CTR_AdExp, OSI_V_gap_CTR_AdExp, OSI_per_energy_V_gap_CTR_AdExp, CV_ISI_tuning_curve_V_gap_CTR_AdExp, CV_ISI_tuning_curve_per_energy_V_gap_CTR_AdExp, MI_tuning_curve_V_gap_CTR_AdExp, MI_tuning_curve_per_energy_V_gap_CTR_AdExp, MICE_tuning_curve_V_gap_CTR_AdExp, MICE_tuning_curve_per_energy_V_gap_CTR_AdExp, CV_ISI_V_gap_CTR_AdExp, CV_ISI_per_energy_V_gap_CTR_AdExp, MI_V_gap_CTR_AdExp, MI_per_energy_V_gap_CTR_AdExp, TE_V_gap_CTR_AdExp, TE_per_energy_V_gap_CTR_AdExp, MICE_V_gap_CTR_AdExp, MICE_per_energy_V_gap_CTR_AdExp, TECE_V_gap_CTR_AdExp, TECE_per_energy_V_gap_CTR_AdExp)                        # append values to results dictionary            for key, value in results_V_gap_CTR_AdExp.items():                results_single_run_V_gap_CTR_AdExp[key].append(value)               # save V_gap CTR results in AdExp dictionary             results_V_gap_FR_AdExp = save_results_dictionary(V_m_V_gap_FR_AdExp, I_syn_e_V_gap_FR_AdExp, I_syn_i_V_gap_FR_AdExp, spike_times_post_V_gap_FR_AdExp, r_post_V_gap_FR_AdExp, E_tot_V_gap_FR_AdExp, CV_V_m_V_gap_FR_AdExp, tuning_curve_V_gap_FR_AdExp, OSI_V_gap_FR_AdExp, OSI_per_energy_V_gap_FR_AdExp, CV_ISI_tuning_curve_V_gap_FR_AdExp, CV_ISI_tuning_curve_per_energy_V_gap_FR_AdExp, MI_tuning_curve_V_gap_FR_AdExp, MI_tuning_curve_per_energy_V_gap_FR_AdExp, MICE_tuning_curve_V_gap_FR_AdExp, MICE_tuning_curve_per_energy_V_gap_FR_AdExp, CV_ISI_V_gap_FR_AdExp, CV_ISI_per_energy_V_gap_FR_AdExp, MI_V_gap_FR_AdExp, MI_per_energy_V_gap_FR_AdExp, TE_V_gap_FR_AdExp, TE_per_energy_V_gap_FR_AdExp, MICE_V_gap_FR_AdExp, MICE_per_energy_V_gap_FR_AdExp, TECE_V_gap_FR_AdExp, TECE_per_energy_V_gap_FR_AdExp)                        # append values to results dictionary            for key, value in results_V_gap_FR_AdExp.items():                results_single_run_V_gap_FR_AdExp[key].append(value)                # add V_gap_absolute_list to results dictionary    results_single_run_V_gap_CTR_LIF['V_rests_list'] = V_rests_list    results_single_run_V_gap_FR_LIF['V_rests_list'] = V_rests_list    results_single_run_V_gap_CTR_AdExp['V_rests_list'] = V_rests_list    results_single_run_V_gap_FR_AdExp['V_rests_list'] = V_rests_list        results_single_CTR_FR_run_V_gap_LIF = [results_single_run_V_gap_CTR_LIF, results_single_run_V_gap_FR_LIF]    results_single_CTR_FR_run_V_gap_AdExp = [results_single_run_V_gap_CTR_AdExp, results_single_run_V_gap_FR_AdExp]        return results_single_CTR_FR_run_V_gap_LIF, results_single_CTR_FR_run_V_gap_AdExpdef multiple_CTR_FR_V_gap_constant_runs(number_V_gap_runs, V_rests, Delta_V_thresh, model_mode, w_scale=95, membrane_noise=0.0, savename=None):     # run multiple moving constant V_gap simulation for CTR & FR         # input    # number_V_gap_runs is the number of V_gap runs to perform    # V_rests is an array of leak potentials/resting potentials    # Delta_V_thresh is the distance to keep constant between  V_rest and V_threshold    # model_mode is a list of strings or string & decides which model is used for simulation    # w_scale is the synaptic scaling factor    # membrane_noise is the standard deviation of the membrane noise in mV/ms    # output     # results_multiple_runs_V_gap_LIF, results_multiple_runs_V_gap_AdExp are the results dictionaries    # initialize dictionaries to save results    results_multiple_runs_V_gap_CTR_LIF, results_multiple_runs_V_gap_CTR_AdExp, results_multiple_runs_V_gap_FR_LIF, results_multiple_runs_V_gap_FR_AdExp = empty_results_dictionary(), empty_results_dictionary(), empty_results_dictionary(), empty_results_dictionary()    results_multiple_runs_V_gap_CTR_LIF['V_rests_list'] = []    results_multiple_runs_V_gap_FR_LIF['V_rests_list'] = []    results_multiple_runs_V_gap_CTR_AdExp['V_rests_list'] = []    results_multiple_runs_V_gap_FR_AdExp['V_rests_list'] = []        # simulate number_V_gap_runs times and save results in results dictionary    for run_number in range(number_V_gap_runs):        results_single_CTR_FR_run_V_gap_LIF, results_single_CTR_FR_run_V_gap_AdExp = single_CTR_FR_V_gap_constant_run(V_rests, Delta_V_thresh, model_mode=model_mode, w_scale=w_scale, membrane_noise=membrane_noise)                for key, value in results_single_CTR_FR_run_V_gap_LIF[0].items():            results_multiple_runs_V_gap_CTR_LIF[key].append(value)        for key, value in results_single_CTR_FR_run_V_gap_LIF[1].items():            results_multiple_runs_V_gap_FR_LIF[key].append(value)                for key, value in results_single_CTR_FR_run_V_gap_AdExp[0].items():            results_multiple_runs_V_gap_CTR_AdExp[key].append(value)                for key, value in results_single_CTR_FR_run_V_gap_AdExp[1].items():            results_multiple_runs_V_gap_FR_AdExp[key].append(value)    results_multiple_CTR_FR_runs_V_gap_LIF = [results_multiple_runs_V_gap_CTR_LIF, results_multiple_runs_V_gap_FR_LIF]    results_multiple_CTR_FR_runs_V_gap_AdExp = [results_multiple_runs_V_gap_CTR_AdExp, results_multiple_runs_V_gap_FR_AdExp]        # save results if savename is provided    if savename is not None:        with open(f'{savename}_results_multiple_CTR_FR_V_gap_constant_runs_LIF.pkl', 'wb') as f:            pickle.dump(results_multiple_CTR_FR_runs_V_gap_LIF, f)        with open(f'{savename}_results_multiple_CTR_FR_V_gap_constant_runs_AdExp.pkl', 'wb') as f:            pickle.dump(results_multiple_CTR_FR_runs_V_gap_AdExp, f)                return results_multiple_CTR_FR_runs_V_gap_LIF, results_multiple_CTR_FR_runs_V_gap_AdExp################################ 3D grid functions ################################def single_grid_run(parameter_ranges, model_mode, membrane_noise=0.0, savename=None):    # run a single grid simulation        # input    # parameter_ranges is a tuple of 3 arrays of the parameter ranges    # model_mode is a list of strings or string & decides which model is used for simulation    # membrane_noise is the standard deviation of the membrane noise in mV/ms    # savename is the name to save the grid as .pkl file    # output     # results_LIF, results_AdExp are the results dictionaries    # load parameter values    # define synaptic input    N_syn, N_e, N_e_signal_ratio, N_i, rate_background_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, mu_weight_e, sigma_weight_e, mu_weight_i, sigma_weight_i = sif.synaptic_parameters()        # create orientation variation input    w_e_0, w_i_0, spike_times_e, spike_times_i, r_e, r_i, t_stim, T, N_e_signal, N_e_noise = sif.orientation_variation_input(N_e, N_i, N_e_signal_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, rate_background_ratio, mu_weight_e, sigma_weight_e, mu_weight_i, sigma_weight_i)    # load standard parameter values    C_m, _, _, _, V_thresh, _, rate_window, E_e, E_i, tau_e, tau_i, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise = sim_parameters(parameter_mode='CTR', membrane_noise=membrane_noise)    # unpack parameter ranges    R_m_values = parameter_ranges[0]    E_L_values = parameter_ranges[1]    w_scale_values = parameter_ranges[2]    number_simulations = len(R_m_values)*len(E_L_values)*len(w_scale_values)    # initialize dictionaries to save results    results_LIF = {}    results_AdExp = {}    # save duration of simulation    start_time = tp.time()        # iterate through all parameter values & their combinations    for R_m in R_m_values:        for E_L in E_L_values:            for w_scale in w_scale_values:                # create a unique key for the results dictionary                key = f'Rm_{R_m}_EL_{E_L}_wscale_{w_scale}'                                # scale synaptic input                w_e = w_e_0 * 20 * w_scale                w_i = w_i_0 * 5 * w_scale                # update parameters                g_L = 10**(3) / R_m  # leak conductance in nS                V_reset = E_L                # translate them to Brian-readable values                T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_b, w_i_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_b, V_thresh_b, V_reset_b, rate_window_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, membrane_noise_b = parameters_brian(T, N_e, N_i, spike_times_e, spike_times_i, E_e, E_i, w_e, w_i, tau_e, tau_i, C_m, g_L, E_L, V_thresh, V_reset, rate_window, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise)                # simulate LIF if given                    if 'LIF' in model_mode:                                        # scale synaptic input                    w_e_LIF_b = w_e_b                    w_i_LIF_b = w_i_b                    # simulate LIF                    time_LIF, V_m_LIF, spike_times_post_LIF, rate_estimate_post_LIF, I_syn_e_LIF, I_syn_i_LIF, g_e_LIF, g_i_LIF = LIF(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_LIF_b, w_i_LIF_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_b, V_thresh_b, V_reset_b, rate_window_b, membrane_noise_b)                    # run full analysis                    r_post_LIF, E_tot_LIF, CV_V_m_LIF, tuning_curve_LIF, OSI_LIF, OSI_per_energy_LIF, CV_ISI_tuning_curve_LIF, CV_ISI_tuning_curve_per_energy_LIF, MI_tuning_curve_LIF, MI_tuning_curve_per_energy_LIF, MICE_tuning_curve_LIF, MICE_tuning_curve_per_energy_LIF, CV_ISI_LIF, CV_ISI_per_energy_LIF, MI_LIF, MI_per_energy_LIF, TE_LIF, TE_per_energy_LIF, MICE_LIF, MICE_per_energy_LIF, TECE_LIF, TECE_per_energy_LIF, E_vec_LIF = af.complete_analysis(spike_times_post_LIF, V_m_LIF, T, R_m, C_m, E_L, I_syn_e_LIF, V_thresh, spike_times_e, w_e, N_e_noise)                    # save results in dictionary                     results_LIF[key] = save_results_dictionary(V_m_LIF, I_syn_e_LIF, I_syn_i_LIF, spike_times_post_LIF, r_post_LIF, E_tot_LIF, CV_V_m_LIF, tuning_curve_LIF, OSI_LIF, OSI_per_energy_LIF, CV_ISI_tuning_curve_LIF, CV_ISI_tuning_curve_per_energy_LIF, MI_tuning_curve_LIF, MI_tuning_curve_per_energy_LIF, MICE_tuning_curve_LIF, MICE_tuning_curve_per_energy_LIF, CV_ISI_LIF, CV_ISI_per_energy_LIF, MI_LIF, MI_per_energy_LIF, TE_LIF, TE_per_energy_LIF, MICE_LIF, MICE_per_energy_LIF, TECE_LIF, TECE_per_energy_LIF)                                    # simulate AdExp if given                  if 'AdExp' in model_mode:                                   # scale synaptic input                    weight_factor_LIF_to_AdExp = 1.0 #1.5                    w_e_AdExp_b = w_e_b * weight_factor_LIF_to_AdExp                    w_i_AdExp_b = w_i_b * weight_factor_LIF_to_AdExp                                        # simulate AdExp                    time_AdExp, V_m_AdExp, spike_times_post_AdExp, rate_estimate_post_AdExp, I_syn_e_AdExp, I_syn_i_AdExp, g_e_AdExp, g_i_AdExp = AdExp(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_AdExp_b, w_i_AdExp_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_b, V_thresh_b, V_reset_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, rate_window_b, membrane_noise_b)                    # run full analysis                    r_post_AdExp, E_tot_AdExp, CV_V_m_AdExp, tuning_curve_AdExp, OSI_AdExp, OSI_per_energy_AdExp, CV_ISI_tuning_curve_AdExp, CV_ISI_tuning_curve_per_energy_AdExp, MI_tuning_curve_AdExp, MI_tuning_curve_per_energy_AdExp, MICE_tuning_curve_AdExp, MICE_tuning_curve_per_energy_AdExp, CV_ISI_AdExp, CV_ISI_per_energy_AdExp, MI_AdExp, MI_per_energy_AdExp, TE_AdExp, TE_per_energy_AdExp, MICE_AdExp, MICE_per_energy_AdExp, TECE_AdExp, TECE_per_energy_AdExp, E_vec_AdExp = af.complete_analysis(spike_times_post_AdExp, V_m_AdExp, T, R_m, C_m, E_L, I_syn_e_AdExp, V_thresh, spike_times_e, w_e, N_e_noise)                    # save results in dictionary                     results_AdExp[key] = save_results_dictionary(V_m_AdExp, I_syn_e_AdExp, I_syn_i_AdExp, spike_times_post_AdExp, r_post_AdExp, E_tot_AdExp, CV_V_m_AdExp, tuning_curve_AdExp, OSI_AdExp, OSI_per_energy_AdExp, CV_ISI_tuning_curve_AdExp, CV_ISI_tuning_curve_per_energy_AdExp, MI_tuning_curve_AdExp, MI_tuning_curve_per_energy_AdExp, MICE_tuning_curve_AdExp, MICE_tuning_curve_per_energy_AdExp, CV_ISI_AdExp, CV_ISI_per_energy_AdExp, MI_AdExp, MI_per_energy_AdExp, TE_AdExp, TE_per_energy_AdExp, MICE_AdExp, MICE_per_energy_AdExp, TECE_AdExp, TECE_per_energy_AdExp)        # save results if savename is provided    if savename is not None:        with open(f'{savename}_results_LIF.pkl', 'wb') as f:            pickle.dump(results_LIF, f)        with open(f'{savename}_results_AdExp.pkl', 'wb') as f:            pickle.dump(results_AdExp, f)        with open(f'input_trains_{savename}.pkl', 'wb') as f:            pickle.dump(spike_times_e, f)        with open(f'input_weights_{savename}.pkl', 'wb') as f:            pickle.dump(w_e_0, f)        # calculate and print simulation duration    end_time = tp.time()    duration_simulation = end_time - start_time    print(f'{number_simulations} grid points executed in {duration_simulation} seconds')        return results_LIF, results_AdExpdef multiple_grid_runs(number_grid_runs, parameter_ranges, model_mode, membrane_noise=0.0, starting_number=1, savename=None):    # run multiple (number_grid_runs) grid simulations        # input    # number_grid_runs is the number of grid runs to     # parameter_ranges is a tuple of 3 arrays of the parameter ranges    # model_mode is a list of strings or string & decides which model is used for simulation    # membrane_noise is the standard deviation of the membrane noise in mV/ms    # starting_number is the number to start saving with    # savename is the name to save the grid as .pkl file    for run_number in range(starting_number, number_grid_runs + starting_number):        savename_run = f'{savename}_{run_number}'         results_LIF, results_AdExp = single_grid_run(parameter_ranges, model_mode, membrane_noise=membrane_noise, savename=savename_run)        ############################# simulation functions Zeldenrust #############################def sim_parameters_Zeldenrust(membrane_noise=0.0): #parameter_mode='excitatory',     # return excitatory or inhibitory parameters        # input    ## parameter_mode is the parameter values for either excitatory or inhibitory     # membrane_noise is the standard deviation of the membrane noise in mV/ms        # output    # C_m is the membrane capacitance in pF    # E_L is the resting potential (leak reversal potential) in mV    # R_m is the membrane resistance equal to leak resistance in MOhm    # g_L is the leak conductance in nS    # V_thresh is the spike generation threshold in mV    # V_reset is the reset potential in mV    # rate_window is the integration time for the online firing-rate estimation in ms      # E_e is the reversal potential for excitatory inputs in mV    # E_i is the reversal potential for inhibitory inputs in mV    # tau_e is the postsynaptic potential (PSP) time constant for exc. input in ms    # tau_i is the postsynaptic potential (PSP) time constant for inh. input in ms    # Delta_T_ad is the AdExp slope factor    # tau_w_ad is the AdExp adaptation time constant    # a_ad is the AdExp subthreshold adaptation    # b_ad is the AdExp spike-triggered adaptation    # membrane_noise is the standard deviation of the membrane noise in mV/ms        # define neuron parameters    C_m = 50 # membrane capacitance in pF # according to Zeldenrust et al. 2024    #if parameter_mode == 'excitatory':     #if parameter_mode == 'inhibitory':     E_L = -70 # initial resting potential (leak reversal potential) in mV # according to Zeldenrust et al. 2024    R_m = 100 # membrane resistance equal to leak resistance in MOhm # 100 according to Zeldenrust et al. 2024    g_L = 10**(3)/R_m # leak conductance in nS    V_thresh = -63 # spike generation threshold in mV # according to Zeldenrust et al. 2024    V_reset = E_L # reset potential in mV         # define rate estimation and Calcium trace    rate_window = 1000 # in ms         # define synaptic parameters    E_e = 0.0 # reversal potential of excitatory synapses in mV    E_i = -80.0 # reversal potential of inhibitory synapses in mV    tau_e = 3.0 # time constant of excitatory synapses in ms # brian 5    tau_i = 5.0 # time constant of inhibitory synapses in ms # brian 10        # AdExp parameters    Delta_T_ad = 1 # AdExp slope factor in mV, according to Zeldenrust et al. 2024, originally 2    tau_w_ad = 10 # AdExp adaptation time constant in ms, according to Zeldenrust et al. 2024 between 0 & 500, originally 144    a_ad = 4 # AdExp subthreshold adaptation in nS, according to Zeldenrust et al. 2024, originally 4    b_ad = 0.0805 # AdExp spike-triggered adaptation in nA, according to Zeldenrust et al. 2024, originally 0.08    membrane_noise = membrane_noise    return C_m, E_L, R_m, g_L, V_thresh, V_reset, rate_window, E_e, E_i, tau_e, tau_i, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noisedef Zeldenrust_single_grid_run(parameter_ranges, neuron_type_mode, membrane_noise=0.0, savename=None):    # run a single grid simulation        # input    # parameter_ranges is a tuple of 3 arrays of the parameter ranges    # neuron_type_mode is a string ('excitatory' or 'inhibitory') determining the switching parameters    # membrane_noise is the standard deviation of the membrane noise in mV/ms    # savename is the name to save the grid as .pkl file    # output     # results is the results dictionary    # load parameter values    # define synaptic input    # define synaptic input    N_syn, N_e, N_e_signal_ratio, N_i, r_on, r_off, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, mu_weight_e, sigma_weight_e, mu_weight_i, sigma_weight_i = sif.synaptic_parameters_switching(neuron_type_mode=neuron_type_mode)    tau_switch = 1000 / (r_on + r_off) # in ms    #N_e_signal_ratio = 0.99    # generate switching input    T = 20000 # ms    w_e_0, w_i_0, spike_times_e, spike_times_i, r_e, r_i, t_stim, N_e_signal, N_e_noise = sif.switching_input(N_e, N_i, N_e_signal_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, mu_weight_e, sigma_weight_e, mu_weight_i, sigma_weight_i, r_on, r_off, T)    # scale synaptic input    w_scale = 14     w_e = w_e_0 * 5 * w_scale * 4 # low E/I balance: 4/1    w_i = w_i_0 * 5 * w_scale * 1 # low E/I balance: 4/1    # load standard parameter values    C_m, E_L, _, _, _, V_reset, rate_window, E_e, E_i, tau_e, tau_i, Delta_T_ad, _, a_ad, b_ad, membrane_noise = sim_parameters_Zeldenrust(membrane_noise=0.0)    # unpack parameter ranges    R_m_values = parameter_ranges[0]    V_thresh_values = parameter_ranges[1]    tau_w_ad_values = parameter_ranges[2]        number_simulations = len(R_m_values)*len(V_thresh_values)*len(tau_w_ad_values)    # initialize dictionary to save results    results = {}    # save duration of simulation    start_time = tp.time()        # iterate through all parameter values & their combinations    for R_m in R_m_values:        for V_thresh in V_thresh_values:            for tau_w_ad in tau_w_ad_values:                # create a unique key for the results dictionary                key = f'Rm_{R_m}_Vt_{V_thresh}_tauwad_{tau_w_ad}'                # update parameters                g_L = 10**(3) / R_m  # leak conductance in nS                # translate them to Brian-readable values                T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_b, w_i_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_b, V_thresh_b, V_reset_b, rate_window_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, membrane_noise_b = parameters_brian(T, N_e, N_i, spike_times_e, spike_times_i, E_e, E_i, w_e, w_i, tau_e, tau_i, C_m, g_L, E_L, V_thresh, V_reset, rate_window, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise)                                # simulate AdExp                time, V_m, spike_times_post, rate_estimate_post, I_syn_e, I_syn_i, g_e, g_i = AdExp(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_b, w_i_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_b, V_thresh_b, V_reset_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, rate_window_b, membrane_noise_b)                # run full analysis                r_post, E_tot, CV_V_m, CV_ISI, CV_ISI_per_energy, MI, MI_per_energy, MICE, MICE_per_energy, MI_vec, E_vec = af.complete_analysis_Zeldenrust(spike_times_post, V_m, T, R_m, C_m, E_L, I_syn_e, V_thresh, t_stim, g_e, neuron_type_mode)                # save results in dictionary                 results[key] = {                    'V_m': np.mean(V_m),                    #'spike_times_post': spike_times_post_AdExp,  # to reduce size of dictionary                    'I_syn_e': np.mean(I_syn_e),                    'I_syn_i': np.mean(I_syn_i),                    'r_post': r_post,                    'E_tot': E_tot,                    'CV_V_m': CV_V_m,                    'CV_ISI': CV_ISI,                    'CV_ISI_per_energy': CV_ISI_per_energy,                    'MI': MI,                    'MI_per_energy': MI_per_energy,                    'MICE': MICE,                     'MICE_per_energy': MICE_per_energy,                    'MI_vec': MI_vec}        # save results if savename is provided    if savename is not None:        with open(f'Zeldenrust_{savename}_results_{neuron_type_mode}.pkl', 'wb') as f:            pickle.dump(results, f)        with open(f'Zeldenrust_input_trains_{savename}_{neuron_type_mode}.pkl', 'wb') as f:            pickle.dump(spike_times_e, f)        with open(f'Zeldenrust_input_weights_{savename}_{neuron_type_mode}.pkl', 'wb') as f:            pickle.dump(w_e_0, f)        # calculate and print simulation duration    end_time = tp.time()    duration_simulation = end_time - start_time    print(f'{number_simulations} grid points executed in {duration_simulation} seconds')        return resultsdef Zeldenrust_multiple_grid_runs(number_grid_runs, parameter_ranges, neuron_type_mode, membrane_noise=0.0, savename=None):    # run multiple (number_grid_runs) Zeldenrust grid simulation        # input    # number_grid_runs is the number of grid runs to     # parameter_ranges is a tuple of 3 arrays of the parameter ranges    # neuron_type_mode is a string ('excitatory' or 'inhibitory') determining the switching parameters    # membrane_noise is the standard deviation of the membrane noise in mV/ms    # savename is the name to save the grid as .pkl file    for run_number in range(1, number_grid_runs + 1):        savename_run = f'{savename}_{run_number}'         results = Zeldenrust_single_grid_run(parameter_ranges, neuron_type_mode, membrane_noise, savename=savename_run)########################################## PCA gridds ##########################################def pca_scores_to_param_dict(pc_vec, pca, features_list, scaler=None, clip_dict=None):    # map a point in PCA score space back to original parameter space (feature units)        # input    # pc_vec is an array of PC coordinates (shape (3,) or (n_components,))    # pca is the fitted PCA object    # features_list is the list of feature names in the same order as PCA input    # scaler is the fitted StandardScaler used before PCA    # clip_dict is an optional dict {name: (lo, hi)} to clip values for safety        # output    # param_dict is a dict mapping feature name -> value     pc_vec = np.asarray(pc_vec, dtype=float).reshape(1, -1)    # inverse PCA -> back to scaled feature space    x_scaled = pca.inverse_transform(pc_vec)  # (1, n_features)    # unscale -> back to original feature units    if scaler is not None:        x = scaler.inverse_transform(x_scaled)    else:        x = x_scaled    x = x.ravel()    param_dict = {name: float(val) for name, val in zip(features_list, x)}    # optional safety clipping    if clip_dict is not None:        for k, (lo, hi) in clip_dict.items():            if k in param_dict:                param_dict[k] = float(np.clip(param_dict[k], lo, hi))    return param_dictdef Zeldenrust_single_grid_run_PCA(scores, std_PCA, grid_points, neuron_type_mode, pca, features_list, scaler=None, membrane_noise=0.0, w_scale=100, clip_dict=None, savename=None):    # run a single grid simulation in 3D PCA score space (PC1/PC2/PC3)        # input    # scores is the PCA scores array used to define PC ranges    # std_PC is the multiplier for the PC standard deviation defining the grid extent    # grid_points is the number of grid points per PC dimension    # neuron_type_mode is a string ('excitatory' or 'inhibitory') determining the switching parameters    # pca is the fitted PCA object    # features_list is the list of feature names in the same order as PCA input    # scaler is the fitted StandardScaler used before PCA (or None)    # membrane_noise is the standard deviation of the membrane noise in mV/ms    # w_scale is the synaptic weight scaling factor used for w_e, w_i    # clip_dict optionally clips reconstructed parameters for safety (dict {name: (lo, hi)})    # savename is the name to save the grid as .pkl file        # output    # results is the results dictionary    # define PC ranges from excitatory PCA scores    mu_PC_1  = np.mean(scores[:, 0])    std_PC_1 = np.std(scores[:, 0])    vals_PC_1 = np.linspace(mu_PC_1 - std_PCA * std_PC_1, mu_PC_1 + std_PCA * std_PC_1, grid_points)    mu_PC_2  = np.mean(scores[:, 1])    std_PC_2 = np.std(scores[:, 1])    vals_PC_2 = np.linspace(mu_PC_2 - std_PCA * std_PC_2, mu_PC_2 + std_PCA * std_PC_2, grid_points)    mu_PC_3  = np.mean(scores[:, 2])    std_PC_3 = np.std(scores[:, 2])    vals_PC_3 = np.linspace(mu_PC_3 - std_PCA * std_PC_3, mu_PC_3 + std_PCA * std_PC_3, grid_points)    pc_ranges = (vals_PC_1, vals_PC_2, vals_PC_3)    # load parameter values    # define synaptic input    N_syn, N_e, N_e_signal_ratio, N_i, r_on, r_off, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, mu_weight_e, sigma_weight_e, mu_weight_i, sigma_weight_i = sif.synaptic_parameters_switching(neuron_type_mode=neuron_type_mode)    #tau_switch = 1000 / (r_on + r_off)  # in ms    # generate switching input    T = 5000  # ms    w_e_0, w_i_0, spike_times_e, spike_times_i, r_e, r_i, t_stim, N_e_signal, N_e_noise = sif.switching_input(N_e, N_i, N_e_signal_ratio, mu_rate_e, sigma_rate_e, mu_rate_i, sigma_rate_i, mu_weight_e, sigma_weight_e, mu_weight_i, sigma_weight_i, r_on, r_off, T)    # scale synaptic input    w_e = w_e_0 * 5 * w_scale * 4  # low E/I balance: 4/1    w_i = w_i_0 * 5 * w_scale * 1  # low E/I balance: 4/1    # load standard parameter values (used as defaults if not part of PCA feature set)    C_m, E_L, R_m, g_L, V_thresh, V_reset, rate_window, E_e, E_i, tau_e, tau_i, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise = sim_parameters_Zeldenrust(membrane_noise=membrane_noise)    # unpack PC ranges    PC1_values = pc_ranges[0]    PC2_values = pc_ranges[1]    PC3_values = pc_ranges[2]    number_simulations = len(PC1_values) * len(PC2_values) * len(PC3_values)    # initialize dictionary to save results    results = {}    # save duration of simulation    start_time = tp.time()    # iterate through all PC values & their combinations    for pc1 in PC1_values:        for pc2 in PC2_values:            for pc3 in PC3_values:                # map PCA point back to parameter/feature space                pc_vec = np.array([pc1, pc2, pc3], dtype=float)                p = pca_scores_to_param_dict(pc_vec, pca=pca, features_list=features_list, scaler=scaler, clip_dict=clip_dict)                # update parameters (only if present in PCA features; otherwise keep defaults)                # NOTE: keys must match exactly your features_list entries                E_L        = p.get("E_L_mV_list", E_L)                V_thresh   = p.get("V_thresh_mV_list", V_thresh)                R_m        = p.get("R_m_mean_MOhm_list", R_m)          # MΩ                C_m        = p.get("C_m_mean_pF_list", C_m)            # pF                Delta_T_ad = p.get("Delta_T_mean_mV_list", Delta_T_ad) # mV                V_reset    = p.get("V_reset_mean_mV_list", V_reset)    # mV                tau_w_ad   = p.get("tau_w_mean_ms_list", tau_w_ad)     # ms                a_ad       = p.get("a_w_mean_nS_list", a_ad)           # nS                b_ad       = p.get("b_w_mean_nA_list", b_ad)           # nA                # basic sanity (prevents negative/zero values that can break Brian)                R_m = max(float(R_m), 1e-6)                C_m = max(float(C_m), 1e-6)                tau_w_ad = max(float(tau_w_ad), 1e-6)                # leak conductance from R_m                g_L = 10**3 / R_m  # leak conductance in nS                # create a unique key for the results dictionary                key = f'PC1_{pc1}_PC2_{pc2}_PC3_{pc3}'                # translate them to Brian-readable values                T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_b, w_i_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_b, V_thresh_b, V_reset_b, rate_window_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, membrane_noise_b = parameters_brian(T, N_e, N_i, spike_times_e, spike_times_i, E_e, E_i, w_e, w_i, tau_e, tau_i, C_m, g_L, E_L, V_thresh, V_reset, rate_window, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise)                # simulate AdExp                time, V_m, spike_times_post, rate_estimate_post, I_syn_e, I_syn_i, g_e, g_i = AdExp(T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_b, w_i_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_b, V_thresh_b, V_reset_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, rate_window_b, membrane_noise_b)                # run full analysis                r_post, E_tot, CV_V_m, CV_ISI, CV_ISI_per_energy, MI, MI_per_energy, MICE, MICE_per_energy, MI_vec, E_vec, hit_fraction, false_alarm_fraction = af.complete_analysis_Zeldenrust(spike_times_post, V_m, T, R_m, C_m, E_L, I_syn_e, V_thresh, t_stim, g_e, neuron_type_mode, dt=0.1)                                # save results in dictionary                results[key] = {                    'pc1': float(pc1),                    'pc2': float(pc2),                    'pc3': float(pc3),                    'E_L': float(E_L),                    'V_thresh': float(V_thresh),                    'R_m': float(R_m),                    'C_m': float(C_m),                    'Delta_T_ad': float(Delta_T_ad),                    'V_reset': float(V_reset),                    'tau_w_ad': float(tau_w_ad),                    'a_ad': float(a_ad),                    'b_ad': float(b_ad),                    'V_m': float(np.mean(V_m)),                    'I_syn_e': float(np.mean(I_syn_e)),                    'I_syn_i': float(np.mean(I_syn_i)),                    'r_post': r_post,                    'E_tot': E_tot,                    'CV_V_m': CV_V_m,                    'CV_ISI': CV_ISI,                    'CV_ISI_per_energy': CV_ISI_per_energy,                    'MI': MI,                    'MI_per_energy': MI_per_energy,                    'MICE': MICE,                    'MICE_per_energy': MICE_per_energy,                    'MI_vec': MI_vec,                    'hit_fraction': hit_fraction,                    'false_alarm_fraction': false_alarm_fraction}    # save results if savename is provided    if savename is not None:        with open(f'Zeldenrust_{savename}_results_{neuron_type_mode}.pkl', 'wb') as f:            pickle.dump(results, f)        with open(f'Zeldenrust_input_trains_{savename}_{neuron_type_mode}.pkl', 'wb') as f:            pickle.dump(spike_times_e, f)        with open(f'Zeldenrust_input_weights_{savename}_{neuron_type_mode}.pkl', 'wb') as f:            pickle.dump(w_e_0, f)    # calculate and print simulation duration    end_time = tp.time()    duration_simulation = end_time - start_time    print(f'{number_simulations} grid points executed in {duration_simulation} seconds')    return resultsdef Zeldenrust_multiple_grid_runs_PCA(number_grid_runs, scores, std_PCA, grid_points, neuron_type_mode, pca, features_list, scaler=None, membrane_noise=0.0, w_scale=100, clip_dict=None, savename=None):    # run multiple Zeldenrust PCA-grid simulations        # input    # number_grid_runs is the number of grid runs to execute    # scores is the PCA scores array used to define PC ranges    # std_PC is the multiplier for the PC standard deviation defining the grid extent    # grid_points is the number of grid points per PC dimension    # neuron_type_mode is a string ('excitatory' or 'inhibitory') determining the switching parameters    # pca is the fitted PCA object    # features_list is the list of feature names in the same order as PCA input    # scaler is the fitted StandardScaler used before PCA (or None)    # membrane_noise is the standard deviation of the membrane noise in mV/ms    # w_scale is the synaptic weight scaling factor used for w_e, w_i    # clip_dict optionally clips reconstructed parameters for safety (dict {name: (lo, hi)})    # savename is the base name to save the grid as .pkl file    for run_number in range(1, number_grid_runs + 1):        savename_run = f'{savename}_{run_number}'        results = Zeldenrust_single_grid_run_PCA(scores, std_PCA, grid_points, neuron_type_mode, pca, features_list, scaler=scaler, membrane_noise=membrane_noise, w_scale=w_scale, clip_dict=clip_dict, savename=savename_run)# OLD DELETEdef OLD_parameters_brian(T, N_e, N_i, spike_times_e, spike_times_i, E_e, E_i, w_e, w_i, tau_e, tau_i, C_m, g_L, E_L, V_thresh, V_reset, rate_window, Delta_T_ad, tau_w_ad, a_ad, b_ad, membrane_noise):    # transforms parameters for brian2        # input and output    # T is the duration of the simulation in ms    # N_e is the number of excitatory synaptic inputs    # N_i is the number of inhibitory synaptic inputs    # spike_times_e is an array of excitatory input spike trains    # spike_times_i is an array of inhibitory input spike trains    # E_e is the reversal potential for excitatory inputs in mV    # E_i is the reversal potential for inhibitory inputs in mV    # w_e are the weights of exc. input    # w_i are the weights of inh. input    # tau_e is the postsynaptic potential (PSP) time constant for exc. input in ms    # tau_i is the postsynaptic potential (PSP) time constant for inh. input in ms    # C_m is the membrane capacitance in pF    # g_L is the leak conductance in nS    # E_L is the resting potential (leak reversal potential) in mV    # V_thresh is the spike generation threshold in mV    # V_reset is the reset potential in mV    # rate_window is the integration time for the online firing-rate estimation in ms    # Delta_T_ad is the AdExp slope factor    # tau_w_ad is the AdExp adaptation time constant    # a_ad is the AdExp subthreshold adaptation    # b_ad is the AdExp spike-triggered adaptation    # membrane_noise is the standard deviation of the membrane noise in mV/ms        T_b = T/1000*second    # define synaptic input     E_e_b = E_e*mV    E_i_b = E_i*mV    w_e_b = w_e*nS    w_i_b = w_i*nS    tau_e_b = tau_e*ms    tau_i_b = tau_i*ms        # define neuron parameters    C_m_b = C_m*pF  # Membrane capacitance    g_L_b = g_L*nS  # Leak conductance    E_L_b = E_L*mV  # Resting potential    V_thresh_b = V_thresh*mV  # Spike generation threshold    V_reset_b = V_reset*mV  # reset potential    # define rate estimation     rate_window_b = rate_window*ms        Delta_T_ad_b = Delta_T_ad * mV  # AdExp slope factor    tau_w_ad_b = tau_w_ad * ms  # AdExp adaptation time constant    a_ad_b = a_ad * nS  # AdExp subthreshold adaptation    b_ad_b = b_ad * nA # AdExp spike-triggered adaptation        membrane_noise_b = membrane_noise * mV/ms # std of the membrane noise     return T_b, N_e, N_i, spike_times_e, spike_times_i, E_e_b, E_i_b, w_e_b, w_i_b, tau_e_b, tau_i_b, C_m_b, g_L_b, E_L_b, V_thresh_b, V_reset_b, rate_window_b, Delta_T_ad_b, tau_w_ad_b, a_ad_b, b_ad_b, membrane_noise_bdef run_Zeldenrust_FR_trajectory(dic_cell_data_FR, max_weight_change_proportion, Delta_R_m, Delta_E_L, Delta_I_syn, n_steps, T, n_sims=5, membrane_noise=1.0):    # simulate sequential AdExp models with continuous changes in R_m, E_L and I_syn    # input    # dic_cell_data_FR is a dictionary containing experimental data and analyzed cell parameters    # max_weight_change_proportion is the maximum of the synaptic weight change    # Delta_R_m is the final relative change of R_m (e.g. 0.2 for +20% R_m at the last step)    # Delta_E_L is the final relative change of E_L (e.g. -0.1 for -10% E_L at the last step)    # Delta_I_syn is the final relative change of the injected / synaptic current I_syn    # n_steps is the number of steps along the trajectory from baseline to the final changes    # T is the simulation duration in seconds    # n_sims is the number of simulations to mean over    # membrane_noise is the standard deviation of the membrane noise in mV/ms        # output    # MI_spike_train_list is a list of length n_steps+1 of the spike-train mutual information values    # fraction_transferred_information_list is a list of length n_steps+1 of the transferred information fractions    hidden_state = np.array(dic_cell_data_FR["hidden_state_exp"])    I_inj_exp = np.array(dic_cell_data_FR["I_inj_exp"])    neuron_type_mode = dic_cell_data_FR["neuron_type_mode"]    dt_original = 0.1    T_window = T * 1000.0    n_window = min(int(T_window / dt_original), len(I_inj_exp), len(hidden_state))    hidden_state_window = hidden_state[:n_window]    I_inj_exp_window = I_inj_exp[:n_window]    C_m = dic_cell_data_FR["C_m_mean_pF"]    R_m_baseline = dic_cell_data_FR["R_m_mean_MOhm"]    E_L_baseline = dic_cell_data_FR["E_L_mV"]    V_thresh = dic_cell_data_FR["V_thresh_mV"]    V_reset = dic_cell_data_FR["V_reset_mean_mV"]    Delta_T = dic_cell_data_FR["Delta_T_mean_mV"]    tau_w = dic_cell_data_FR["tau_w_mean_ms"]    a_w = dic_cell_data_FR["a_w_mean_nS"]    b_w = dic_cell_data_FR["b_w_mean_nA"]    tau_ref = 8 # ms        R_m_list = []    E_L_list = []    I_syn_nA_list = []    MI_list = []    fraction_transferred_information_list = []    r_post_list = []    V_m_mean_list = []    V_m_std_list = []    spike_times_post_list = []    hit_fraction_list = []    false_alarm_fraction_list = []    E_tot_list = []    MICE_list = []    MICE_per_energy_list = []    for step in range(n_steps + 1):        frac = float(step) / float(n_steps)        R_m_step = R_m_baseline * (1.0 + frac * Delta_R_m)        E_L_step = E_L_baseline * (1.0 + frac * Delta_E_L)        I_inj_exp_step = I_inj_exp_window * (1.8 + frac * Delta_I_syn) # for membrane noise of 5 mV/ms: 1.5 + frac * Delta_I_syn        MI_tmp, frac_info_tmp, r_post_tmp, V_m_mean_tmp, V_m_std_tmp, hit_tmp, false_alarm_tmp, E_tot_tmp, spike_times_tmp, R_m_tmp, E_L_tmp, I_syn_nA_tmp, MICE_tmp, MICE_per_energy_tmp = ([] for _ in range(14))        for _ in range(n_sims):            t_vec_sim, V_m_sim, spike_times_post_sim = dafZ.AdExp_I_inj(I_inj_exp_step * pA, C_m * pF, R_m_step * Mohm, E_L_step * mV, V_thresh * mV, V_reset * mV, Delta_T * mV, tau_w * ms, a_w * nS, b_w * nA, tau_ref * ms, membrane_noise = membrane_noise * mV/ms)            r_post = len(spike_times_post_sim) / T  # is the postsynaptic firing rate in Hz            E_tot, E_HK, E_RP, E_AP, E_ST, E_glu, E_Ca = af.E_tot_eq(R_m_step, C_m, E_L_step, r_post, np.asarray(I_inj_exp_step)/1000, V_thresh)            E_vec = (E_tot, E_HK, E_RP, E_AP, E_ST, E_glu, E_Ca)                    # variability of the substhreshold membrane voltage            CV_V_m = af.calculate_CV_V_m(V_m_sim, V_thresh)                # calculate coefficient of variation            CV_ISI = af.calculate_CV_ISI(spike_times_post_sim)            CV_ISI_per_energy = CV_ISI / E_tot *10**9            MI_I, MI_spike_train, MI_I_spike_train, H_xx, H_xy_input, H_xy_output, fraction_transferred_entropy, fraction_transferred_information = af.calculate_mutual_information_experimental_data_Zeldenrust(hidden_state_window, np.asarray(I_inj_exp_step)/1000, spike_times_post_sim, T*1000, neuron_type_mode=neuron_type_mode)            MI = MI_spike_train            MI_per_energy = MI/E_tot*10**9            MICE = MI / r_post            MICE_per_energy = MI_per_energy / r_post                hit_fraction, false_alarm_fraction = af.hit_rate(spike_times_post_sim, hidden_state_window, dt=dt_original)            R_m_tmp.append(R_m_step)            E_L_tmp.append(E_L_step)            I_syn_nA_tmp.append(np.mean(np.asarray(I_inj_exp_step)/1000))            MI_tmp.append(MI)            frac_info_tmp.append(fraction_transferred_information)            r_post_tmp.append(r_post)            V_m_mean_tmp.append(np.mean(V_m_sim))            V_m_std_tmp.append(np.std(V_m_sim))            hit_tmp.append(hit_fraction)            false_alarm_tmp.append(false_alarm_fraction)            E_tot_tmp.append(E_tot)            spike_times_tmp.append(spike_times_post_sim)            MICE_tmp.append(MICE)            MICE_per_energy_tmp.append(MICE_per_energy)        R_m_list.append(np.mean(R_m_tmp))        E_L_list.append(np.mean(E_L_tmp))        I_syn_nA_list.append(np.mean(I_syn_nA_tmp))        MI_list.append(np.mean(MI_tmp))        fraction_transferred_information_list.append(np.mean(frac_info_tmp))        r_post_list.append(np.mean(r_post_tmp))        V_m_mean_list.append(np.mean(V_m_mean_tmp))        V_m_std_list.append(np.mean(V_m_std_tmp))        hit_fraction_list.append(np.mean(hit_tmp))        false_alarm_fraction_list.append(np.mean(false_alarm_tmp))        E_tot_list.append(np.mean(E_tot_tmp))        spike_times_post_list.append(spike_times_tmp)        MICE_list.append(MICE_tmp)        MICE_per_energy_list.append(MICE_per_energy_tmp)            return MI_list, fraction_transferred_information_list, r_post_list, V_m_mean_list, V_m_std_list, spike_times_post_list, MICE_list, MICE_per_energy_list, hit_fraction_list, false_alarm_fraction_list, E_tot_list, R_m_list, E_L_list, I_syn_nA_list